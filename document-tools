#!/usr/bin/env python3
## Generates documentation of all of the bash aliases and shell functions
## defined in all of the specified files, and of all of the scripts contained
## in the specified directories, provided that they don't run afoul of our
## limitations (for which see next).
#
#  Limitations: we assume that
#  ===========
#  - all bash shell function definitions start with the optional 'function'
#    keyword
#  - no comment and no line's indentation - that is, the consecutive
#    whitespace at the start of a line - contains a tab character (though we
#    only check for them in lines whose indentation or comments we're
#    interested in, and we reserve the right to change which lines those are,
#    so you should make sure you never use them in comments or indentation if
#    you plan to use this script)
#    - we terminate immediately upon encountering a tab where we forbid them
#  - bash shell function definitions end with a closing brace at the start of
#    a line that's indented the same amount or less than the first line of
#    the definition (that is, the line that starts with the 'function'
#    keyword)
#    - we also assume that such closing braces don't occur in here documents
#      or anywhere else that would require sophisticated parsing to determine
#      that it's not a "real" closing brace with the appropriate indentation
#  - bash shell function definitions don't contain other alias or shell
#    function definitions (though I'm not even sure either is allowed)
#
# Note that the existence of one or more 'cycles' among aliases that just
# rename other aliases or functions can result in our generating an org mode
# document that cannot be exported to other formats (due to unresolvable
# links).
#
#  Documentation Comments
#  ======================
#  - the comments from which we extract documentation are
#    - all of the comments indented underneath an alias definition,
#    - all of the comments that immediately precede a shell function
#      definition, and
#    - the comment block at the start of a script (ignoring any 'shebang'
#      line)
#  - there cannot be blank lines between an alias or function definition and
#    the comments that document them: if there are then they won't be
#    considered to be comments that document the alias or function
#  - there cannot be blank lines among the comments that document something,
#    though there can be blank comment lines (that is, lines that start with
#    a - possibly indented - comment character followed by nothing but zero
#    or more whitespace characters)
#    - if there are then the comment lines will be considered to be two
#      separate comment blocks and so won't be considered to be part of the
#      documentation of the same thing (alias definition, function definition,
#      etc.)
#  - the comment lines that document something are split into paragraphs on
#    blank comment lines
#    - two or more consecutive blank comment lines are warned about, but are
#      otherwise treated as a single blank comment line in this case
#  - comment lines that start with 2 consecutive comment characters will be
#    included in both the summary and full description of the thing that they
#    document
#  - comment lines that start with any other number of comment characters
#    will only be included in the full description of the thing that they
#    document, though those starting with 3 or more comment characters will
#    be warned about
#  - as noted in the Limitations section, comments cannot contain tabs
#  - comment lines whose consecutive comment characters are followed by
#    two or more consecutive spaces are included verbatim in the
#    documentation that we generate
#  - comment lines whose consecutive comment characters are followed by
#    exactly one space are flowed together with any and all other such
#    comment lines immediately before and after them into a single paragraph
#    in the documentation that we generate
#
# Copyright (C) 2020-2022 by James MacKay.
#
#-This program is free software: you can redistribute it and/or modify
#-it under the terms of the GNU General Public License as published by
#-the Free Software Foundation, either version 3 of the License, or
#-(at your option) any later version.
#
#-This program is distributed in the hope that it will be useful,
#-but WITHOUT ANY WARRANTY; without even the implied warranty of
#-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#-GNU General Public License for more details.
#
#-You should have received a copy of the GNU General Public License
#-along with this program.  If not, see <https://www.gnu.org/licenses/>.
#

# TODO: can we link to man pages (or failing that info pages) in 'See also'
# sections???!!!!????
# - find out how the 'info' program does it: google it or read the source
# TODO: clicking on the local file: org mode link to most scripts doesn't
# seem to work!!!!!
# - seems only to work when the file has a file extension (e.g. .sh)?
# - we get a 'Runnning viewer ...' message otherwise
# - look up file: links in the org mode manual? Maybe this is how they're
#   supposed to work?
#   - in which case can we get them to just open the file in a buffer
#     instead, and if so how?

import datetime, getopt, os, re, sys

from abc import ABC, abstractmethod

from typing import ClassVar, Dict, List, Optional, Type, TypeVar


##
## Types.
##

Paragraph = str
Pathname = str


##
## Constants.
##

# The maximum width - in characters - that lines in the generated documents
# should have.
_lineWidth: int = 77

# The text that must be at the very start of a file's contents in order for
# us to consider it to be a script.
_scriptStart: str = "#!"

# When we display the pathname of a file we've processed in the generated
# documentation, for each environment variable that exists and whose name is
# a key in this dictionary if the pathname starts with the environment
# variable's value then that part of the pathname is replaced with the
# corresponding value in this dictionary unless that value is None, in which
# case that part of the pathname is replaced with the environment variable's
# name preceded by '$' (so it looks like a bash shell variable reference).
_pathnameEnvVarNames: Dict[str, str] = {
    "HOME": "~",
    "GROUP_HOME": None
}

# The character that starts a bash comment.
_commentStart: str = "#"

# A regular expression that matches the (first or second) line of a script
# that specifies information to Emacs about how it should handle the file
# (such as whether to treat its contents as read-only), and a helper
# regex that matches the '-*-' part of such a line.
_emacsMarkerRegex: str = re.escape("-*-")
_emacsLineRegex: str = "^\\s*" + _commentStart + "\\s*" + \
    _emacsMarkerRegex + "\\s+.*\\s+" + _emacsMarkerRegex + "\\s*$"

# A list of all of the regular expressions that a comment line - excluding
# the comment character(s) at the start of it - in a script's top comment
# must *not* match in order for it to be considered to be part of the
# script's documentation.
_excludeFromScriptDocsRegexes: List[str] = [
    "^[^\\s]+",  # lines w/ no whitespace after the comment chars
    "^\\s+Copyright\\s+",  # lines that start with the word 'Copyright'
    "^\\s*" + _emacsMarkerRegex + "\\s+" + re.escape("coding: utf-8") + \
        "\\s+" + _emacsMarkerRegex,
]


# The basename of the scripts.org files that we link into iff our '-P' option
# is specified.
_scriptsOrgBasename: str = "scripts.org"


# The newline character.
_newline: str = '\n'

# The tab character.
_tab: str = '\t'

# The closing brace character.
_closingBrace: str = "}"

# The character that starts a bash shell variable.
_shellVariableStart: str = "$"


# The bash 'alias' keyword.
_aliasKeyword: str = "alias"

# The bash 'function' keyword.
_functionKeyword: str = "function"

# A regular expression pattern that matches the start of a bash alias
# definition: optional (horizontal) whitespace followed by 'alias' followed
# by whitespace followed by one or more non-whitespace characters followed by
# optional whitespace followed by an equals sign (=).
#
# Note: we don't specify a type hint for this since I don't know what the
# type of a compiled regular expression is (that is, what the type of the
# result of re.compile() is).
_aliasDefinitionStartRegex = re.compile("[ \t]*" + re.escape(_aliasKeyword) +
                                        "[ \t]+[^ \t]+[ \t]*=")

# The text to append to the name of a shell function to identify it as a
# shell function.
#
# Note: we intentionally don't depend on this in any important way: currently
# we just look for a function to link to first when a name ends with this
# suffix in a 'See also:' list.
#
# See also: Function._formattedNameFmt.
_functionSpecifierSuffix: str = "()"

# The text that a paragraph of documentation must start with in order for us
# to assume that it's (potentially) a list of the names of things to also
# see.
_seeAlsoParagraphStart: str = "See also:"

# The text that a paragraph of documentation must start with in order for us
# to assume that it's a paragraph giving a brief description of how to use
# the things being documented.
_usageParagraphStart: str = "usage:"


# The format for our usage message.
_usageMessageFmt: str = """
usage: {prog} [-h|-q|-s|-v] [-P] file...

If the '-h' option is specified then this usage message is
output to standard output and we exit with exit code 0.

Otherwise we generate documentation of all of the bash aliases
and shell functions defined in all of the files in 'file...', as
well as of all of the scripts - and symbolic links to scripts -
in all of the directories in 'file...'.

By default all notes, warnings and errors are written to
standard error. But if the '-v' option is specified then
informational messages are written there as well, if the '-q'
option is specified then only warnings and errors are reported,
and if the '-s' option is specified then nothing will ever be
reported.

If the '-P' option is specified then in the generated document
as many local file links as possible will be into one of my
'""" + _scriptsOrgBasename + """' files.
"""


#
# Documentation part formats.
#

# The title of the document that we generate.
_title: str = "Bash Aliases, Functions and Scripts"

# The author of the document that we generate.
#_author: str = "James MacKay"
_author: str = "Autogenerated by '{}'". \
    format(os.path.basename(os.path.realpath(sys.argv[0])))

# The start/prologue of the org mode document that we generate.
#
# Note: to use a (yet to be written) custom CSS stylesheet instead of the
# 'readtheorg' one - possibly because the latter isn't properly installed or
# set up on the current machine - replace the #+SETUPFILE line in the first
# paragraph with the following line (after removing the first '#'):
#
#,#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="bash-aliases-functions-and-scripts.css" />
#
# The first commented out SETUPFILE line below also assumes that the
# repository containing the theme has been cloned locally and the proper
# symlinks into it have been set up in the directory that the exported HTML
# file will be in. To use the theme author's repository directly instead then
# use the second commented out SETUPFILE line below (again, after removing
# the first '#'):
#
#,#+SETUPFILE: org-html-themes/org/theme-readtheorg-local.setup
#,#+SETUPFILE: https://fniessen.github.io/org-html-themes/org/theme-readtheorg.setup
_orgPrologueFmt: str = """# -*- eval: (read-only-mode 1) -*-
#+TITLE: {title}
#+AUTHOR: {author}
#+LANGUAGE: en
#+OPTIONS: toc:nil ^:nil
#+EXPORT_SELECT_TAGS: export
#+EXPORT_EXCLUDE_TAGS: noexport

[ [[#Introduction-top-section][Introduction]] | [[#Summaries-top-section][Summaries]] | [[#Descriptions-top-section][Descriptions]] | [[#Index-top-section][Index]] ]
"""

_orgIntroductionSectionStart: str = """
* Introduction
  :PROPERTIES:
  :CUSTOM_ID: Introduction-top-section
  :END:
"""

# The text that immediately precedes the list of all of the directories
# whose script files we document, assuming that a list of the files whose
# contents we document preceded us.
#
# See also: _orgDirectoriesListOnlyStart.
_orgDirectoriesListStart: str = """
It also contains information about all of the scripts - and symbolic links
to scripts - that are contained in the following directories:

"""

# The text that immediately precedes the list of all of the directories
# whose script files we document, assuming that a list of the files whose
# contents we document has *not* preceded us.
#
# See also: _orgDirectoriesListStart.
_orgDirectoriesListOnlyStart: str = """
This document contains information about all of the scripts - and symbolic
links to scripts - that are contained in the following directories:

"""

# The text that immediately precedes the list of all of the files whose
# contents we document.
_orgFilesListStart: str = """
This document contains information about all of the bash aliases and
functions that are defined in all of the following files:

"""

_orgIntroductionSectionEnd: str = """
The [[#Summaries-top-section][Summaries]] section contains a brief summary of each alias and function,
each of which links to the (usually) more extensive description of it in our
[[#Descriptions-top-section][Descriptions]] section. The [[#Index-top-section][Index]] consists of just the names of all of the
aliases and functions, where each is a link to the subsection of the
Descriptions section that describes it.

We document {} aliases, {} functions, {} scripts and {} symbolic links to
scripts.
"""

# The start of the 'Summaries' section of the org mode document.
_orgSummariesSectionStart: str = """
* Summaries
  :PROPERTIES:
  :CUSTOM_ID: Summaries-top-section
  :END:

*Note:* each name links to the appropriate subsection of the [[#Descriptions-top-section][Descriptions]]
section.
"""

# The summaries used for undocumented Documentables that just rename
# something else: which is used depends on whether the thing it renames is
# something we document or not.
_defaultRenamesDocumentableSummaryFmt: str = \
    "This is {} {}."
_defaultRenamesNondocumentableSummaryFmt: str = \
    "This is {} the {} program."

# The summary used for undocumented things.
#
# Note: it's intentionally fairly ugly so that they stand out (as a reminder
# for me to document them).
_undocumentedSummaryFmt: str = \
    "This is an *UNDOCUMENTED* {}."

# The full description used for undocumented things.
#
# Note: it's intentionally fairly ugly so that they stand out (as a reminder
# for me to document them).
_undocumentedDescriptionFmt: str = \
    "This {} is currently *UNDOCUMENTED*."

# The summary used for documented things whose documentation doesn't include
# a summary.
#
# Note: it's intentionally fairly ugly so that they stand out (as a reminder
# for me to summarize them).
_unsummarizedSummaryFmt: str = \
    "This is an *UNSUMMARIZED* {}."

# The start of the 'Descriptions' section of the org mode document.
_orgDescriptionsSectionStart: str = """
* Descriptions
  :PROPERTIES:
  :CUSTOM_ID: Descriptions-top-section
  :END:
"""

# The start of each subsection of the 'Descriptions' section that describes
# a Documentable (alias, function, etc.).
#
# See also: _orgDocumentableDescriptionEnd,
# _orgWholeFileDocumentableDescriptionEnd.
_orgDocumentableDescriptionStart: str = """
** {}
  :PROPERTIES:
  :CUSTOM_ID: {}
  :END:
"""

# The end of each subsection of the 'Descriptions' section that describes
# a Documentable (alias, function, etc.): one is used when the Documentable's
# definition consists of the entirety of the file it's in and the other is
# for ones that don't.
#
# See also: _orgDocumentableDescriptionStart.
_orgDocumentableDescriptionEnd: str = """
This {} is defined on {} of {}.
"""
_orgWholeFileDocumentableDescriptionEnd: str = """
This {} is {}.
"""

# The start of the 'Index' section of the org mode document.
_orgIndexSectionStart: str = """
* Index
  :PROPERTIES:
  :CUSTOM_ID: Index-top-section
  :END:

*Note:* each link is to the appropriate subsection of the [[#Descriptions-top-section][Descriptions]]
section.
"""

# The end/epilogue of the org mode document that we generate.
_orgEpilogueFmt: str = """
Generated {when}.
"""


#
# Message formats.
#

_aliasesItselfFmt: str = \
    "the '{}' alias aliases itself"
_aliasEventuallyAliasesItselfFmt: str = \
    "the '{}' alias indirectly aliases itself: {}"
_aliasRenamerKindDescription: str = \
    "an alias for"
_alreadyAliasFmt: str = \
    "there's already an alias named '{}': it's defined at {}"
_alreadyFunctionFmt: str = \
    "there's already a shell function named '{}': it's defined at {}"
_alreadyScriptFmt: str = \
    "there's already (a symbolic link to) a script named '{}' with " \
    "pathname {}"
_badUsageMessageProgramNameFmt: str = \
    "the part of the usage message for the {} {} after '{}' doesn't " \
    "start with the word '{}'."
_commentIndentedMoreThanPrecedingOneFmt: str = \
    "the comment block starting at {} is indented more than the one " \
    "right before it that starts on line {}: are they supposed to be part " \
    "of the same comment block?"
_consecutiveBlankLinesBlocksFmt: str = \
    "the block of blank lines at {} is followed by another block of " \
    "blank lines at line {}, which should never happen"
_consecutiveCommentBlocksWithSameIndentFmt: str = \
    "the comment block starting at {} is followed by another comment " \
    "block at line {} that's indented the same amount, which should " \
    "never happen"
_consecutiveOtherCodeBlocksFmt: str = \
    "the block of other code at {} is followed by another block of " \
    "other code at line {}, which should never happen"
_differentScriptCommentLineIndentFmt: str = \
    "this line in the script's top comment is indented a different amount " \
    "than the first line in the comment is"
_extraStartingCommentCharsFmt: str = \
    "there are {} comment characters ({}) at the start, but there should " \
    "be at most two"
_hidesDocumentableFmt: str = \
    "potentially hides/shadows the {} named '{}' that's defined at {}"
    # we only say 'potentially' since we don't know which one ends up taking
    # precedence over the other (since we don't know which is defined last)
_ignoringNonscriptFmt: str = \
    "ignoring this file since its first line doesn't start with '{}' and " \
    "so we assume it isn't a script"
_invalidSourceTypeFmt: str = \
    "ignoring the file '{}' since it isn't a regular file or directory " \
    "(or a symbolic link to one)"
_linePositionFmt: str = \
    "line {} in the file {}"
_missingAliasNameFmt: str = \
    "the name of the alias being defined is missing"
_missingAliasValueFmt: str = \
    "the value part of the definition of the '{}' alias is missing"
_missingFunctionNameFmt: str = \
    "the name of the function being defined is missing"
_missingSeeAlsoContentsFmt: str = \
    "there's nothing after '{}' in the documentation for the {} {}."
_missingSummaryFmt: str = \
    "the documentation for '{}' doesn't include a summary"
_missingUsageMessageFmt: str = \
    "there's nothing after '{}' in the usage message for the {} {}."
_noArgumentsInFunctionFmt: str = \
    "the function's arguments - which start with '{}' - are missing"
_noNameValueSeparatorInAliasFmt: str = \
    "the alias' definition doesn't contain the name-value separator '{}'"
_noSpaceAfterCommentStartFmt: str = \
    "there should be at least one space after the starting comment " \
    "character(s)"
_noSuchDirectoryFmt: str = \
    "the directory '{}' doesn't exist"
_noSuchFileFmt: str = \
    "the file '{}' doesn't exist"
_possibleAliasInFunctionFmt: str = \
    "this alias definition is considered to be part of the function " \
    "definition that starts on line {}, possibly because the closing " \
    "brace at the end of that function's definition is indented further " \
    "than its first line. (Aliases can legally be defined in functions, " \
    "but we can't currently document them.)"
_possibleFunctionInFunctionFmt: str = \
    "this function definition is considered to be part of the function " \
    "definition that starts on line {}, possibly because the closing " \
    "brace at the end of that other function's definition is indented " \
    "further than its first line"
_scriptCommentIndentedFmt: str = \
    "the comment at the top of this script - or at least the first line " \
    "of it - is indented"
_scriptHiddenFmt: str = \
    "this {} named '{}' is hidden/shadowed by the {} defined at {}"
_scriptLinkRenamerKindDescription: str = \
    "a symbolic link to"
_seeAlsoFunctionNotFunctionFmt: str = \
    "in the '{}' part of the documentation of the {} {} '{}' refers to a " \
    "nonexistent shell function"
_shellVariableAsNameFmt: str = \
    "skipping this {} since its name ('{}') looks like a shell variable's " \
    "value (because it starts with '{}') and so we can't determine its " \
    "real name"
_tabInIndentFmt: str = \
    "indentation of {} contains one or more tabs"
_undocumentedAliasFmt: str = \
    "there is no comment indented immediately under the definition " \
    " of the '{}' shell alias"
_undocumentedFunctionFmt: str = \
    "there is no comment block immediately preceding the definition " \
    " of the '{}' shell function"
_undocumentedScriptFmt: str = \
    "there is no comment block at the top of this script"
_unexpectedLineFmt: str = \
    "unexpected line - skipping it since we don't know how to parse it"


##
## Exception classes.
##

class DocumentationException(Exception):
    """
    The base class for all of our exception classes.
    """
    pass


class ParsingException(DocumentationException):
    """
    Raised to indicate a problem during parsing.
    """
    def __init__(self, msg: str, pos: 'LinePosition') -> None:
        """
        Initializes us with our message and the position of the line that was
        being parsed.
        """
        assert pos is not None
        super().__init__(msg)
        self._position = pos.copy()

    def position(self) -> 'LinePosition':
        """
        Returns the position of the line where the problem with parsing was
        encountered.
        """
        result: 'LinePosition' = self._position
        assert result is not None
        return result


class TabInIndentationException(ParsingException):
    """
    The class of exception that's raised when a tab character is found in the
    indentation of a line.
    """
    pass


##
## Functions.
##

def debug(fmt: str, *args) -> None:
    """
    Outputs a debugging message built from the format string 'fmt' and the
    arguments 'args'.
    """
    assert fmt is not None
    w = sys.stderr
    w.write("DEBUG: ")
    w.write(fmt.format(*args))
    w.write(_newline)

def out(w, txt: str = "") -> None:
    """
    Outputs the text 'txt' to the output stream 'w'.
    """
    assert w is not None
    assert txt is not None  # but can be empty
    print(txt, file = w)

def readNextLineFrom(r,
                     pos: Optional['LinePosition'] = None) -> Optional[str]:
    """
    Reads and returns the next line from the readable stream 'r' and returns
    it with any newline removed from the end of it, or returns None if there
    is no next line. Iff 'pos' isn't None then its line number is incremented
    iff we don't return None.
    Reads the next line from the readable stream 'r' and returns it
    (without any newline at the end of it), or sets '_nextLine' to None
    and returns None if there is no next line.
    """
    assert r is not None
    # 'pos' can be None
    result: Optional[str] = r.readline()
    if not result:
        result = None
    else:
        # Increment the next line's position and remove the newline from
        # the end of it.
        if pos is not None:
            pos.incrementLineNumber()
        assert pos.isValid()
        assert result.endswith(_newline)
        result = result[:-1]
        #debug("next line is [{}]", result)
    # 'result' can be None
    return result

def usage(msg: str = None, w = None) -> None:
    """
    Writes out a usage message for this program to the output stream 'w'
    (or standard error if 'w' is None), predeced by 'msg' iff it's not None.
    """
    if w is None:
        w = sys.stderr
    if msg is not None:
        out(w)
        out(w, msg)
    prog = os.path.basename(sys.argv[0])
    out(w, _usageMessageFmt.format(prog = prog))


##
## Classes.
##

class LinePosition:
    """
    The position of a line in a file being parsed.
    """
    @staticmethod
    def displayablePathname(f: Pathname) -> str:
        """
        Returns the displayable representation of the pathname 'f'.
        """
        assert f is not None
        result: str = f
        env = os.environ
        name: str
        for name in _pathnameEnvVarNames:
            val: str = env.get(name)
            if val is not None and f.startswith(val):
                prefix: str = _pathnameEnvVarNames[name]
                if prefix is None:  # use the default prefix: '$name'
                    prefix = "$" + name
                result = "{}{}".format(prefix, f[len(val):])
                break  # for

        # Ensure that directories end in '/'.
        if os.path.isdir(f):
            sep: str = "/"
            if not f.endswith(sep):
                result += sep
        assert result is not None
        return result


    def __init__(self, pathname: Pathname, initialLineNum: int = 1) -> None:
        """
        Initializes us with the pathname of the file that our position is in
        and the 1-based line number of the line it's in.

        Note: we allow our initial line number to be zero since that can
        simplify some code, but most of our methods will fail if they're
        called when our line number is still zero. Also see isValid().
        """
        #debug("---> LinePosition.__init__({}, {})", pathname, initialLineNum)
        assert pathname
        assert os.path.isabs(pathname)
        assert initialLineNum >= 0  # even though it's 1-based
        self._pathname: Pathname = pathname
        self._lineNum: int = initialLineNum
        assert self._lineNum >= 0

    def __str__(self) -> str:
        # Note: we access our fields directly here so that this will work
        # even when we represent an invalid line position.
        pathname: str = self.displayablePathname(self._pathname)
        result: str = _linePositionFmt.format(self._lineNum, pathname)
        assert result is not None
        return result

    def __repr__(self) -> str:
        # Note: we access our fields directly here so that this will work
        # even when we represent an invalid line position.
        result: str = "{}({}, {})".format(self.__class__.__name__,
                                          self._pathname, self._lineNum)
        assert result
        return result


    def isValid(self) -> bool:
        """
        Returns True iff we currently represent a valid position for a line.
        """
        return (self._lineNum > 0)

    def pathname(self) -> Pathname:
        """
        Returns the pathname of the file we're in.
        """
        assert self.isValid()
        result: Pathname = self._pathname
        assert result
        assert os.path.isabs(result)
        return result

    def lineNumber(self) -> int:
        assert self.isValid()
        result: int = self._lineNum
        assert result > 0  # since it's 1-based
        return result

    def incrementLineNumber(self) -> None:
        """
        Increases our line number part by one.
        """
        self._lineNum += 1
        assert self._lineNum > 0
        assert self.isValid()

    # def setLineNumber(self, lineNum: int) -> None:
    #     """
    #     Sets our line number to be 'lineNum'.
    #     """
    #     assert lineNum >= 0
    #     self._lineNum = lineNum
    #     assert (lineNum > 0) == self.isValid()

    def copy(self) -> 'LinePosition':
        """
        Returns a copy of us.
        """
        assert self.isValid()
        result: LinePosition = LinePosition(self._pathname, self._lineNum)
        assert result is not None
        return result


class Reporter(ABC):
    """
    An abstract base class for classes that report information, issues and
    problems.
    """
    @abstractmethod
    def inform(self, fmt: str, *args) -> None:
        """
        Reports a piece of information built from the format string 'fmt'
        and the arguments 'args'.

        See also: informAt().
        """
        assert fmt
        pass

    @abstractmethod
    def informAt(self, pos: LinePosition, fmt: str, *args) -> None:
        """
        Reports a piece of information built from the format string 'fmt'
        and the arguments 'args' that describes something at position 'pos'.

        See also: inform().
        """
        assert fmt
        pass

    @abstractmethod
    def note(self, fmt: str, *args) -> None:
        """
        Reports a note built from the format string 'fmt' and the arguments
        'args'.

        A note should be used instead of a warning to report something that
        might be wrong, but might also be perfectly fine.

        See also: noteAt().
        """
        assert fmt
        pass

    @abstractmethod
    def noteAt(self, pos: LinePosition, fmt: str, *args) -> None:
        """
        Reports a note built from the format string 'fmt' and the arguments
        'args' that describes something at position 'pos'.

        A note should be used instead of a warning to report something that
        might be wrong, but might also be perfectly fine.

        See also: note().
        """
        assert pos is not None
        assert fmt
        pass

    @abstractmethod
    def warn(self, fmt: str, *args) -> None:
        """
        Reports a warning built from the format string 'fmt' and the
        arguments 'args'.

        A warning should be used instead of a note to report something that
        is almost certainly wrong, but which can be ignored if the user wants
        to.

        See also: warnAt().
        """
        assert fmt
        pass

    @abstractmethod
    def warnAt(self, pos: LinePosition, fmt: str, *args) -> None:
        """
        Reports a warning built from the format string 'fmt' and the
        arguments 'args' that describes something at position 'pos'.

        A warning should be used instead of a note to report something that
        is almost certainly wrong, but which can be ignored if the user wants
        to.

        See also: warn().
        """
        assert pos is not None
        assert fmt
        pass

    @abstractmethod
    def alert(self, fmt: str, *args) -> None:
        """
        Reports an error whose description is built from the format string
        'fmt' and the arguments 'args'.

        See also: alertAt().
        """
        assert fmt
        pass

    @abstractmethod
    def alertAt(self, pos: LinePosition, fmt: str, *args) -> None:
        """
        Reports an error whose description is built from the format string
        'fmt' and the arguments 'args' that describes something at position
        'pos'.

        See also: alert().
        """
        assert pos is not None
        assert fmt
        pass


class AbstractReporter(Reporter):
    """
    An abstract base class for most Reporter subclasses.
    """
    def inform(self, fmt: str, *args) -> None:
        assert fmt
        self._reportInformation(self._buildMessage(fmt, *args))

    def informAt(self, pos: LinePosition, fmt: str, *args) -> None:
        assert fmt
        self._reportInformation(self._buildMessageAt(pos, fmt, *args))

    def note(self, fmt: str, *args) -> None:
        assert fmt
        self._reportNote(self._buildMessage(fmt, *args))

    def noteAt(self, pos: LinePosition, fmt: str, *args) -> None:
        assert pos is not None
        assert fmt
        self._reportNote(self._buildMessageAt(pos, fmt, *args))

    def warn(self, fmt: str, *args) -> None:
        assert fmt
        self._reportWarning(self._buildMessage(fmt, *args))

    def warnAt(self, pos: LinePosition, fmt: str, *args) -> None:
        assert pos is not None
        assert fmt
        self._reportWarning(self._buildMessageAt(pos, fmt, *args))

    def alert(self, fmt: str, *args) -> None:
        assert fmt
        self._reportError(self._buildMessage(fmt, *args))

    def alertAt(self, pos: LinePosition, fmt: str, *args) -> None:
        assert pos is not None
        assert fmt
        self._reportError(self._buildMessageAt(pos, fmt, *args))


    def _buildMessageAt(self, pos: LinePosition, fmt: str, *args) -> str:
        """
        Builds and returns a message from the format string 'fmt' and the
        arguments 'args' that describes something at position 'pos'.
        """
        assert pos is not None
        assert fmt
        result: str = self._buildMessage("{}:{}: " + fmt, pos.pathname(),
                                         pos.lineNumber(), *args)
        assert result
        return result

    def _buildMessage(self, fmt: str, *args) -> str:
        """
        Builds and returns a message from the format string 'fmt' and the
        arguments 'args'.
        """
        assert fmt
        result: str = fmt.format(*args)
        assert result
        return result


    @abstractmethod
    def _reportInformation(self, msg: str) -> None:
        """
        Reports the informational message 'msg'.
        """
        assert msg
        pass

    @abstractmethod
    def _reportNote(self, msg: str) -> None:
        """
        Reports the note/notice message 'msg'.
        """
        assert msg
        pass

    @abstractmethod
    def _reportWarning(self, msg: str) -> None:
        """
        Reports the warning message 'msg'.
        """
        assert msg
        pass

    @abstractmethod
    def _reportError(self, msg: str) -> None:
        """
        Reports the error message 'msg'.
        """
        assert msg
        pass


class CountingReporter(Reporter):
    """
    A Reporter that delegates the actual reporting to another Reporter, but
    that also keeps track of how many of each type of message it forwards to
    that other Reporter for reporting (regardless of whether that other
    Reporter actually ends up reporting it).
    """
    def __init__(self, delegate: Reporter) -> None:
        """
        Initializes us with the Reporter to which we delegate the actual
        reporting of messages.
        """
        assert delegate is not None
        self._delegate: Reporter = delegate
        self._infoCount: int = 0
        self._noteCount: int = 0
        self._warningCount: int = 0
        self._errorCount: int = 0


    def infoCount(self) -> int:
        """
        Returns the number of informational messages we've reported so far.
        """
        result: int = self._infoCount
        assert result >= 0
        return result

    def noteCount(self) -> int:
        """
        Returns the number of notes we've reported so far.
        """
        result: int = self._noteCount
        assert result >= 0
        return result

    def warningCount(self) -> int:
        """
        Returns the number of warnings we've reported so far.
        """
        result: int = self._warningCount
        assert result >= 0
        return result

    def errorCount(self) -> int:
        """
        Returns the number of errors we've reported so far.
        """
        result: int = self._errorCount
        assert result >= 0
        return result


    def inform(self, fmt: str, *args) -> None:
        assert fmt
        self._delegate.inform(fmt, *args)
        self._infoCount += 1

    def informAt(self, pos: LinePosition, fmt: str, *args) -> None:
        assert fmt
        self._delegate.informAt(pos, fmt, *args)
        self._infoCount += 1

    def note(self, fmt: str, *args) -> None:
        assert fmt
        self._delegate.note(fmt, *args)
        self._noteCount += 1

    def noteAt(self, pos: LinePosition, fmt: str, *args) -> None:
        assert pos is not None
        assert fmt
        self._delegate.noteAt(pos, fmt, *args)
        self._noteCount += 1

    def warn(self, fmt: str, *args) -> None:
        assert fmt
        self._delegate.warn(fmt, *args)
        self._warningCount += 1

    def warnAt(self, pos: LinePosition, fmt: str, *args) -> None:
        assert pos is not None
        assert fmt
        self._delegate.warnAt(pos, fmt, *args)
        self._warningCount += 1

    def alert(self, fmt: str, *args) -> None:
        assert fmt
        self._delegate.alert(fmt, *args)
        self._errorCount += 1

    def alertAt(self, pos: LinePosition, fmt: str, *args) -> None:
        assert pos is not None
        assert fmt
        self._delegate.alertAt(pos, fmt, *args)
        self._errorCount += 1


class SelectiveReporter(Reporter):
    """
    A Reporter that delegates the actual reporting to another Reporter, but
    that only actually passes along those reporting requests that are of a
    sufficiently high severity.
    """

    # Report severity levels.
    _all: ClassVar[int] = 0
    _atLeastInfo: ClassVar[int] = 1
    _atLeastNote: ClassVar[int] = 2
    _atLeastWarning: ClassVar[int] = 3
    _atLeastError: ClassVar[int] = 4
    _nothing: ClassVar[int] = 5

    def __init__(self, delegate: Reporter) -> None:
        """
        Initializes us with the Reporter to which we delegate the actual
        reporting of messages. We delegate all reporting requests initially.

        See also: setOnlyReportNotesOrWorse(), etc.
        """
        assert delegate is not None
        self._delegate: Reporter = delegate
        self._minLevel = self._all
        assert self._minLevel >= self._all
        assert self._minLevel <= self._nothing

    def setReportNothing(self) -> None:
        """
        Modifies us so that we don't pass along *any* reporting requests.
        """
        self._minLevel = self._nothing

    def setReportInfoOrWorse(self) -> None:
        """
        Modifies us so that we only pass along reporting requests that are
        informational or worse.
        """
        self._minLevel = self._atLeastInfo

    def setReportNoteOrWorse(self) -> None:
        """
        Modifies us so that we only pass along reporting requests that are
        notes or worse.
        """
        self._minLevel = self._atLeastNote

    def setReportWarningOrWorse(self) -> None:
        """
        Modifies us so that we only pass along reporting requests that are
        warnings or worse.
        """
        self._minLevel = self._atLeastWarning

    def setReportErrorOrWorse(self) -> None:
        """
        Modifies us so that we only pass along reporting requests that are
        errors/alerts or worse.
        """
        self._minLevel = self._atLeastError

    def setReportEverything(self) -> None:
        """
        Modifies us so that we pass along *all* reporting requests.
        """
        self._minLevel = self._all


    def inform(self, fmt: str, *args) -> None:
        assert fmt
        if self._minLevel <= self._atLeastInfo:
            self._delegate.inform(fmt, *args)

    def informAt(self, pos: LinePosition, fmt: str, *args) -> None:
        assert fmt
        if self._minLevel <= self._atLeastInfo:
            self._delegate.informAt(pos, fmt, *args)

    def note(self, fmt: str, *args) -> None:
        assert fmt
        if self._minLevel <= self._atLeastNote:
            self._delegate.note(fmt, *args)

    def noteAt(self, pos: LinePosition, fmt: str, *args) -> None:
        assert pos is not None
        assert fmt
        if self._minLevel <= self._atLeastNote:
            self._delegate.noteAt(pos, fmt, *args)

    def warn(self, fmt: str, *args) -> None:
        assert fmt
        if self._minLevel <= self._atLeastWarning:
            self._delegate.warn(fmt, *args)

    def warnAt(self, pos: LinePosition, fmt: str, *args) -> None:
        assert pos is not None
        assert fmt
        if self._minLevel <= self._atLeastWarning:
            self._delegate.warnAt(pos, fmt, *args)

    def alert(self, fmt: str, *args) -> None:
        assert fmt
        if self._minLevel <= self._atLeastError:
            self._delegate.alert(fmt, *args)

    def alertAt(self, pos: LinePosition, fmt: str, *args) -> None:
        assert pos is not None
        assert fmt
        if self._minLevel <= self._atLeastError:
            self._delegate.alertAt(pos, fmt, *args)


class StreamReporter(AbstractReporter):
    """
    A Reporter that reports everything by writing messages to a specified
    writable text stream.
    """
    # The prefixes prepended to various types of messages.
    informationPrefix: ClassVar[str] = "Info: "
    notePrefix: ClassVar[str] = "Note: "
    warningPrefix: ClassVar[str] = "Warning: "
    errorPrefix: ClassVar[str] = "ERROR: "

    # The suffix appended to all messages.
    suffix: ClassVar[str] = _newline


    def __init__(self, w) -> None:
        """
        Initializes us with the writable text stream 'w' that we're to write
        our messages to.
        """
        assert w is not None
        super().__init__()
        self._stream = w

    def _reportInformation(self, msg: str) -> None:
        assert msg
        self._report(self.informationPrefix, msg)

    def _reportNote(self, msg: str) -> None:
        assert msg
        self._report(self.notePrefix, msg)

    def _reportWarning(self, msg: str) -> None:
        assert msg
        self._report(self.warningPrefix, msg)

    def _reportError(self, msg: str) -> None:
        assert msg
        self._report(self.errorPrefix, msg)

    def _report(self, prefix: str, msg: str) -> None:
        """
        Reports the message 'msg' preceded by the prefix 'prefix'.
        """
        w = self._stream
        w.write(prefix)
        w.write(msg)
        w.write(self.suffix)


class StderrReporter(StreamReporter):
    """
    A Reporter that reports everything by writing messages to standard error.
    """
    def __init__(self) -> None:
        super().__init__(sys.stderr)


class ReporterFactory:
    """
    Represents factories that can create various types of Reporters.
    """

    def makeStream(self, w) -> StreamReporter:
        """
        Returns a new Reporter that reports things by writing them to the
        writable text stream 'w'.
        """
        assert w is not None
        result: StreamReporter = StreamReporter(w)
        assert result is not None
        return result

    def makeStderr(self) -> StderrReporter:
        """
        Returns a new Reporter that reports things by writing them to
        standard error.
        """
        result: StderrReporter = StderrReporter()
        assert result is not None
        return result

    def makeCounting(self, r: Reporter) -> CountingReporter:
        """
        Returns a new CountingReporter that gets 'r' to actually report
        things, but that also keeps track of how many reporting requests of
        each severity level it receives.
        """
        assert r is not None
        result: CountingReporter = CountingReporter(r)
        assert result is not None
        return result

    def makeSelective(self, r: Reporter) -> SelectiveReporter:
        """
        Returns a new SelectiveReporter that gets 'r' to actually report
        things, but that can be configured to only pass along to 'r' those
        requests of a specified minimum severity.

        Initially it will pass along *all* requests to 'r'.

        See also: SelectiveReporter.setReportWarningOrWorse(), etc.
        """
        assert r is not None
        result: SelectiveReporter = SelectiveReporter(r)
        assert result is not None
        return result


class DocumentablesSources:
    """
    Represents all of the locations that can contain things that we document
    (that is, Documentables).

    TODO: ensure that we properly handle symlinks to files and directories
    properly!!! (See our really() method.)
    """

    @staticmethod
    def really(pathname: Pathname) -> Pathname:
        """
        Returns the absolute pathname of the actual file that 'pathname'
        refers to, eliminating any and all symbolic links in that pathname.

        See also: os.path.realpath().
        """
        assert pathname is not None
        result: Pathname = os.path.realpath(pathname)
        assert result is not None
        assert os.path.isabs(result)
        return result

    def __init__(self, pathnames: List[Pathname], rep: Reporter) -> None:
        """
        Initializes us with the pathnames of the files and directories that
        contain all of things that are to be documented (aka Documentables),
        reporting any and all problems and issues using 'rep'.
        """
        assert pathnames is not None  # but it can be empty
        assert rep is not None
        self._files: List[Pathname] = []  # regular files
        self._dirs: List[Pathname] = []
        p: Pathname
        for p in pathnames:
            real: Pathname = self.really(p)
            if os.path.isdir(real):
                self._dirs.append(p)
            elif os.path.isfile(real):
                self._files.append(p)
            else:
                rep.warn(_invalidSourceTypeFmt, p)
        assert self._files is not None
        assert self._dirs is not None

    def isEmpty(self) -> bool:
        """
        Returns True iff we contain no sources.

        See also: areFileSources(), areDirectorySources().
        """
        return not (self.areFileSources() or self.areDirectorySources())

    def areFileSources(self) -> bool:
        """
        Returns True iff we have at least one source that's a (regular) file.

        See also: files(), isEmpty(), areDirectorySources().
        """
        return (len(self._files) > 0)  # so we return a bool, not a list

    def areDirectorySources(self) -> bool:
        """
        Returns True iff we have at least one source that's a directory.

        See also: directories(), isEmpty(), areFileSources().
        """
        return (len(self._dirs) > 0)  # so we return a bool, not a list


    def files(self) -> Pathname:
        """
        Yields the pathnames of all of the regular files that are sources for
        Documentables.

        See also: areFileSources().
        """
        result: Pathname
        for result in self._files:
            assert result is not None
            yield result

    def directories(self) -> Pathname:
        """
        Yields the pathnames of all of the directories that are sources for
        Documentables.

        See also: areDirectorySources().
        """
        result: Pathname
        for result in self._dirs:
            assert result is not None
            yield result

    def hasDirectory(self, p: Pathname) -> bool:
        """
        Returns True iff 'p' is the pathname of one of the directories that
        is a source for Documentables.
        """
        assert p is not None
        return (p in self._dirs)

    def hasFile(self, p: Pathname) -> bool:
        """
        Returns True iff  'p' is the pathname of one of the regular files
        that is a source for Documentables.
        """
        assert p is not None
        return (p in self._files)

    def directoryContents(self, d: Pathname) -> Pathname:
        """
        Yields the pathnames of all of the files in and under the directory
        with pathname 'd' that may be Documentables.

        We only include regular files and symbolic links to regular files,
        and we omit any files that are already one of our sources for
        Documentables.
        """
        assert d is not None
        assert self.hasDirectory(d)
        result: Pathname
        for result in os.listdir(d):
            result = os.path.join(d, result)
            if not self.hasFile(result):
                real: Pathname = self.really(result)
                if os.path.isfile(real):
                    assert result is not None
                    yield result


T = TypeVar('T')

class ItemDocumentation:
    """
    Represents the documentation associated with a single item (like an
    alias or function definition).
    """

    @classmethod
    def parseComments(cls: Type[T], comments: 'CommentBlock',
                      rep: Reporter,
                      excludeLineRegexes: Optional[List[str]] = None) -> T:
        """
        Parses all of the lines in 'comments' and returns the
        ItemDocumentation that represents any and all documentation that
        could be extracted from it.

        Iff 'excludeLineRegexes' isn't None then if a line in 'comments' -
        after removing the comment character(s) from the start of it -
        matches *any* of the regular expressions in it then that line is
        excluded from our result.

        Note: the lines in 'comments' are assumed to still start (ignoring
        any indentation, which may or may not have been removed before
        they're passed to us) with their comment start character (that is,
        '#').

        See also: _commentStart.
        """
        #debug("---> ItemDocumentation.parseComments([{}], rep) ...", ", ".join(comments.lines()) )
        assert comments is not None  # though it may be empty
        fullDesc: List[Paragraph] = []
        summary: List[Paragraph] = []
        pos: LinePosition = comments.firstLinePosition()
        line: str
        currDescPara: Paragraph = ""
        currSummPara: Paragraph = ""
        prevIndentSz: int = -1
            # the size of the indent of the line immediately preceding the
            # current one, or -1 if there's no preceding line or it was blank
        for line in comments.lines():
            line = line.lstrip()
            count: int = cls._startingCommentCharacterCount(line, pos, rep)
            if count >= 3:
                rep.warnAt(pos, _extraStartingCommentCharsFmt, count,
                           _commentStart)
            line = line[count:]  # remove all starting comment chars
            if cls._matchesAnyRegexIn(excludeLineRegexes, line):
                continue  # omit 'line' from our documentation

            isBlank: bool = BlockParser.isBlankLine(line)
            if (not isBlank) and (not line[0].isspace()):
                rep.warnAt(pos, _noSpaceAfterCommentStartFmt)

            indentSz: int = Block.lineIndentSize(line, pos)
            if isBlank or ((prevIndentSz >= 0) and
                           cls._isNewParagraphIndent(indentSz,
                                                     prevIndentSz)):
                # Note: consecutive blank lines do *not* cause a new empty
                # paragraph to be added.
                if isBlank:
                    prevIndentSz = -1
                if currDescPara:
                    fullDesc.append(currDescPara)
                    currDescPara = ""
                if currSummPara:
                    summary.append(currSummPara)
                    currSummPara = ""
            if not isBlank:
                isInSummary: bool = (count == 2)
                #("convert-base" in line) and debug("==> indent[{}] = {}", line, indentSz)
                if indentSz <= 1:
                    # Append 'line' *without* the leading space to the
                    # current paragraphs, preceded by a space when we're not
                    # at the start of a paragraph.
                    line = line[indentSz:].rstrip()
                    if currDescPara:
                        currDescPara += " "
                    currDescPara += line
                    if isInSummary:
                        if currSummPara:
                            currSummPara += " "
                        currSummPara += line
                else:
                    # Append 'line' - without any trailing whitespace and
                    # with one less leading space - as a separate line.
                    assert indentSz > 1
                    line = line[1:].rstrip()
                    if currDescPara:
                        currDescPara = currDescPara + _newline + line
                    else:
                        currDescPara = line
                    if isInSummary:
                        if currSummPara:
                            currSummPara = currSummPara + _newline + line
                        else:
                            currSummPara = line
                prevIndentSz = indentSz
            pos.incrementLineNumber()
        if currDescPara:
            fullDesc.append(currDescPara)
        if currSummPara:
            summary.append(currSummPara)
        result: ItemDocumentation = ItemDocumentation(summary, fullDesc)
        assert result is not None
        return result

    @staticmethod
    def _matchesAnyRegexIn(regexes: Optional[List[str]], txt: str) -> bool:
        """
        Returns True iff 'regexes' is not None and 'txt' matches at least one
        of the regular expressions in it.
        """
        # 'regexes' can be None
        assert txt is not None
        result: bool = False
        if regexes:
            regex: str
            for regex in regexes:
                if re.match(regex, txt):
                    result = True
                    break  # for regex ...
        return result

    @staticmethod
    def _isNewParagraphIndent(currIndentSz: int, prevIndentSz: int) -> bool:
        """
        Returns True iff the current comment line - which is assumed to be
        non-blank and which is assumed to have 'currIndentSz' spaces between
        the last comment character at the start of it and the first
        non-space character after that - should be considered the first line
        of a new paragraph if the immediately preceding line's corresponding
        'indentation' is 'prevIndentSz' spaces.
        """
        assert currIndentSz >= 0
        assert prevIndentSz >= 0
        result: bool = False
        if prevIndentSz <= 1:
            # The current line starts a new paragraph iff it's the start of a
            # 'verbatim' line. (We combine consecutive non-verbatim lines
            # into a single paragraph even if they're indented different
            # amounts since they can only be indented zero or one spaces and
            # we consider (and have reported) zero indentation as a mis-typed
            # one-space indent.)
            result = (currIndentSz > 1)
        else:
            # The current line starts a new paragraph iff it's *not* the
            # start of a 'verbatim' line. (We combine consecutive verbatim
            # lines into a single paragraph even if they're indented
            # different amounts.)
            assert prevIndentSz > 1
            result = (currIndentSz <= 1)
        return result

    @staticmethod
    def _startingCommentCharacterCount(line: str, pos: LinePosition,
                                       rep: Reporter) -> int:
        """
        Returns the number of consecutive _commentStart characters at the
        start of the line 'line' at position 'pos' after any indentation.
        """
        assert line  # since it must contain at least one _commentStart char
        assert rep is not None
        commentChar: str = _commentStart
        result: int = 0
        ch: str
        for ch in line.strip():
            if ch != commentChar:
                break  # for
            result += 1
        assert result >= 1
        return result

# FUTURE: do we want to handle usage messages in the documentation specially???!!!!???
    def __init__(self, summary: List[Paragraph],
                 fullDesc: List[Paragraph]) -> None:
        """
        Initializes us with the item's summary and full description.
        """
        assert summary is not None   # though it may be empty
        assert fullDesc is not None  # though it may be empty
        self._summary: List[Paragraph] = summary
        self._fullDescription: List[Paragraph] = fullDesc

    def summary(self) -> List[Paragraph]:
        """
        Returns the summary description of the item.

        Despite our return type an item's summary should be kept pretty short
        and so should rarely if ever consist of more than one Paragraph.
        """
        result: List[Paragraph] = self._summary
        assert result is not None  # though it can be empty
        return result

    def fullDescription(self) -> List[Paragraph]:
        """
        Returns the full description of the item.
        """
        result: List[Paragraph] = self._fullDescription
        assert result is not None  # though it can be empty
        return result


class Documentable(ABC):
    """
    The interface implemented by all of the classes that represent things
    that we can document.
    """

    @abstractmethod
    def name(self) -> str:
        """
        Returns our name.
        """
        pass
        #assert result

    @abstractmethod
    def otherNames(self) -> List[str]:
        """
        Returns all of the other names for us.

        See also: addOtherName().
        """
        pass
        #assert result is not None  # but it may be empty

    @abstractmethod
    def addOtherName(self, name: str) -> bool:
        """
        Adds 'name' to the list of all of the other names for us and
        returns True unless 'name' is already another name for us, in which
        case it isn't added and we return False.

        See also: otherNames().
        """
        #assert name
        pass
        #assert self.otherNames()  # since at least 'name' is one

    @abstractmethod
    def formattedName(self) -> str:
        """
        Returns the formatted version of our name: that is, the name as it
        should appear in the generated documentation.

        See also: formattedTypedName().
        """
        pass
        #assert result

    def formattedTypedName(self) -> str:
        """
        Returns the formatted version of our name that includes some sort of
        indicator of what type of Documentable we are.

        Our result can be used in the generated documentation to distinguish
        Documentables with the same name but different types in contexts
        where the name of the Documentable is (alomst) the only thing being
        displayed, or where a less compact indication of its type is
        undesirable.

        See also: formattedName().
        """
        pass
        #assert result


    @abstractmethod
    def id(self) -> str:
        """
        Returns a string that uniquely identifies this Documentable across
        all of the ones in a given set of Documentation.

        Note: the value should be suitable for use as both an HTML anchor
        and an org mode CUSTOM_ID: it shouldn't contain any whitespace
        characters, for one thing.
        """
        pass
        #assert result  # cannot be an empty string

    @abstractmethod
    def kindName(self) -> str:
        """
        Returns a name that uniquely identifies the kind of Documentable
        we are.
        """
        pass
        #assert result  # cannot be an empty string

    @abstractmethod
    def doesRename(self) -> bool:
        """
        Returns True iff we just provide another name for another alias,
        shell function, script, command, etc.

        See also: renamedName().
        """
        pass

    @abstractmethod
    def renamerKindDescription(self) -> str:
        """
        Returns a human-readable description of the kind of renaming
        Documentable this is, suitable for preceding the name of the thing
        (Documentable or not) that we rename.
        """
        assert self.doesRename()
        pass
        #assert result is not None

    @abstractmethod
    def renamedName(self) -> str:
        """
        Returns the name of the alias, shell function, script or command that
        this alias provides another name for.
        """
        assert self.doesRename()
        pass
        #assert result

    @abstractmethod
    def findUltimateRenamed(self: T) -> Optional[T]:
        """
        Returns the last Documentable in our renaming chain, or returns None
        if there's nothing on that chain or we don't just rename other things
        (and so don't have a renaming chain).

        See also: RenamingAlias.renamingChain().
        """
        pass
        # 'result' can be None


    @abstractmethod
    def isEntireFile(self) -> bool:
        """
        Returns True iff our definition consists of the entirety of the file
        that it's in.
        """
        pass

    @abstractmethod
    def firstLinePosition(self) -> LinePosition:
        """
        Returns the position of the first line of this thing.
        """
        pass
        #assert result is not None

    @abstractmethod
    def definitionStart(self) -> str:
        """
        Returns the text at the start of our definition, at least if our
        definition follows the standard format (including standard whitespace
        use), or returns an empty string if our definition is always at the
        start of its file.

        Note: we make no guarantees about how much of the start of a
        definition this matches: it's mainly intended for use in matching the
        start of a definition.
        """
        pass
        #assert result is not None

    @abstractmethod
    def hasDocumentation(self) -> bool:
        """
        Returns True iff there's documentation about us.
        """
        pass

    @abstractmethod
    def documentation(self) -> ItemDocumentation:
        """
        Returns the documentation about us.
        """
        #assert self.hasDocumentation()
        pass
        #assert result is not None


class AbstractDocumentable(Documentable):
    """
    An abstract base class for Documentables.
    """
    # The format string used to build our instances' IDs.
    #
    # See also: id(), kindName().
    _idFmt: ClassVar[str] = "{}-{}"

    def __init__(self, name: str, pos: LinePosition,
                 doc: Optional[ItemDocumentation] = None) -> None:
        """
        Initializes us with our name, the position of our first line and any
        documentation about us.

        Note: 'pos' should be the position of the first line of the thing
        itself, not including any documentation about the thing.
        """
        assert name
        assert pos is not None
        # 'doc' can be None
        super().__init__()
        self._name: str = name
        self._documentation: Optional[ItemDocumentation] = doc
        self._firstLinePosition: LinePosition = pos.copy()
        self._otherNames: List[str] = []

    def __str__(self) -> str:
        result: str = "{}({}, pos={})". \
            format(self.__class__.__name__, self.name(),
                   self.firstLinePosition())
        assert result is not None
        return result

    def name(self) -> str:
        result: str = self._name
        assert result
        return result

    def otherNames(self) -> List[str]:
        result: List[str] = self._otherNames
        assert result is not None  # but it may be empty
        return result

    def addOtherName(self, name: str) -> bool:
        assert name
        # Note: we're doing a linear search through _otherNames here, but
        # that list is expected to never get very large so it shouldn't be
        # a bottleneck.
        c: List[str] = self._otherNames
        result: bool = (name not in c)
        if result:
            self._otherNames.append(name)
        assert self.otherNames()

    def formattedName(self) -> str:
        result: str = self.name()
        assert result
        return result

    def id(self) -> str:
        result: str = self._idFmt.format(self.name(), self.kindName())
        result = result.replace(' ', '_')
            # ensure there are no spaces in the ID
        assert result
        return result


    def doesRename(self) -> bool:
        return False

    def renamerKindDescription(self) -> str:
        assert self.doesRename()
        raise NotImplementedError()
            # we should never get called since our doesRename() method always
            # returns False: if that method is overridden then this one
            # should be too
        #assert result is not None

    def renamedName(self) -> str:
        assert self.doesRename()
        raise NotImplementedError()
            # we should never get called since our doesRename() method always
            # returns False: if that method is overridden then this one
            # should be too
        #assert result

    def findUltimateRenamed(self) -> Optional[Documentable]:
        # 'result' can be None
        return None


    def isEntireFile(self) -> bool:
        return False

    def firstLinePosition(self) -> LinePosition:
        result: LinePosition = self._firstLinePosition
        assert result is not None
        return result

    def hasDocumentation(self) -> bool:
        return (self._documentation is not None)

    def documentation(self) -> ItemDocumentation:
        assert self.hasDocumentation()
        result: ItemDocumentation = self._documentation
        assert result is not None
        return result


class Alias(AbstractDocumentable):
    """
    An abstract base class for alias definitions.
    """
    # The keyword at the start of every alias definition.
    keyword: ClassVar[str] = _aliasKeyword

    # The string that separates an alias' name from its value.
    nameValueSeparator: ClassVar[str] = "="


    # The name of this kind of documentable.
    _kindName: ClassVar[str] = "alias"

    def kindName(self) -> str:
        result: str = self._kindName
        assert result
        return result

    def formattedTypedName(self) -> str:
        # We just use the plain alias name as its typed representation.
        result: str = self.name()
        assert result
        return result

    def definitionStart(self) -> str:
        result: str = "{} {}{}".format(self.keyword, self.name(),
                                       self.nameValueSeparator)
        assert result is not None
        return result


class RenamingAlias(Alias):
    """
    The definition of a bash alias that just provides another - often
    shorter - name for something else.

    We use the term 'renaming' here not in the sense of replacing something's
    name, but in the sense of adding another name to it. A better term would
    be 'aliasing', but that seems fraught with peril given how much we deal
    with (bash) aliases.

    Note: we treat these differently depending on whether they provide
    another name for something we document or something we don't (like a
    shell script, for example).
    """
    def __init__(self, name: str, renamedName: str, pos: LinePosition,
                 doc: Optional[ItemDocumentation] = None) -> None:
        """
        Initializes us with the name of this alias, the name 'renamedName' of
        the alias, shell function, etc. that we provide another name for and
        any documentation about this alias.

        See also: setRenamed().
        """
        assert name
        assert renamedName
        # 'renamed' can be None
        assert pos is not None
        # 'doc' can be None
        super().__init__(name, pos, doc)
        self._renamedName: str = renamedName
        self._renamingChain: List[Documentable] = []
            # a list whose first item is the Documentable that we rename,
            # whose second is the Documentable that the first item renames,
            # etc. (so every item in this list except possibly the last one
            # is a RenamingAlias).
        assert self._renamedName
        assert self._renamingChain is not None
        assert not self._renamingChain  # i.e. it's empty but not None

    def doesRename(self) -> bool:
        return True

    def renamerKindDescription(self) -> str:
        assert self.doesRename()
        result: str = _aliasRenamerKindDescription
        assert result is not None
        return result

    def renamedName(self) -> str:
        assert self.doesRename()
        result: str = self._renamedName
        assert result
        return result

    def addRenamingToRenamingChain(self, d: Documentable,
                                   rep: Reporter) -> bool:
        """
        Adds 'd' - which can provide another name for a Documentable - to the
        end of the chain of Documentables that starts with us, returning True
        unless 'd' couldn't be added  (which we'll have warned about using
        'rep'), in which case we'll return False instead.
        """
        assert d is not None
        assert rep is not None
        return self._addToRenamingChain(d, rep, isRenaming = True)

    def addNonrenamingToRenamingChain(self, d: Documentable,
                                      rep: Reporter) -> bool:
        """
        Adds 'd' - which *cannot* provide another name for a
        Documentable - to the end of the chain of Documentables that starts
        with us, returning True unless 'd' couldn't be added (which we'll
        have warned about using 'rep'), in which case we'll return False
        instead.
        """
        assert d is not None
        assert rep is not None
        return self._addToRenamingChain(d, rep, isRenaming = False)

    def _addToRenamingChain(self, d: Documentable, rep: Reporter,
                            isRenaming: bool) -> bool:
        """
        Adds 'd' - which can provide another name for a Documentable iff
        'isRenaming' is True - to the end of the chain of Documentables that
        starts with us, returning True unless 'd' couldn't be added  (which
        we'll have warned about using 'rep'), in which case we'll return
        False instead.

        See also: addRenamingToRenamingChain(),
        addNonrenamingToRenamingChain().
        """
        #debug("---> RenamingAlias._addToRenamingChain(self={}, d={}, rep, isRenaming = {}) ...", self, d, isRenaming)
        assert d is not None
        assert rep is not None
        result: bool = True
        # Detect cycles in our renaming chain, warn about them and do *not*
        # add them. Note 'd' can only create a cycle if it can rename
        # something else: ones that can't aren't checked because they can
        # result in false positives due to their name matching that of a
        # thing with the same name that's already been added.
        if isRenaming and (d.name() == self.name()):
            rep.warnAt(self.firstLinePosition(), _aliasesItselfFmt, d.name())
        else:
            cd: Documentable
            for cd in self._renamingChain:
                if d.name() == cd.name():
                    result = False
                    if isRenaming:
                        rep.warnAt(self.firstLinePosition(),
                                   _aliasEventuallyAliasesItselfFmt,
                                   self.name(),
                                   self._describeRenamingChain())
        if result:
            self._renamingChain.append(d)
        return result

    def findUltimateRenamed(self) -> Optional[Documentable]:
        c: List[str] = self._renamingChain
        result: Optional[Documentable] = None
        if c:
            result = c[-1]  # last item
            assert result is not None
        # 'result' can be None
        return result

    def renamingChain(self) -> List[Documentable]:
        """
        Returns our renaming chain: a list whose first item is the
        Documentable that we rename, whose second is the Documentable that
        the first item renames, etc.

        (So every item in our result except possibly the last one is a
        RenamingAlias).
        """
        result: List[Documentable] = self._renamingChain
        assert result is not None  # though it may be empty
        return result

    def _describeRenamingChain(self) -> str:
        """
        Returns a concise description of our renaming chain.
        """
        result: str = self.name()
        d: Documentable
        for d in self._renamingChain:
            result += " renames " + d.name()
        assert result
        return result


class DefinedAlias(Alias):
    """
    The definition of a bash alias that doesn't just provide a different name
    for something else: it also specifies options and/or arguments, for
    example.
    """
    pass


class Function(AbstractDocumentable):
    """
    The definition of a bash shell function.
    """
    # The keyword (that we assume is) at the start of every shell function
    # definition.
    keyword: ClassVar[str] = _functionKeyword

    # The string at the start of a function definition's argument
    # declarations part.
    argumentsStart: ClassVar[str] = "("

    # The name of this kind of documentable.
    _kindName: ClassVar[str] = "function"

    # The format string used to build our formatted name.
    _formattedNameFmt: ClassVar[str] = "{}" + _functionSpecifierSuffix

    def kindName(self) -> str:
        result: str = self._kindName
        assert result
        return result

    def formattedName(self) -> str:
        result: str = self._formattedNameFmt.format(self.name())
        assert result
        return result

    def formattedTypedName(self) -> str:
        result: str = self.formattedName()
        assert result
        return result

    def definitionStart(self) -> str:
        result: str = "{} {}{}".format(self.keyword, self.name(),
                                       self.argumentsStart)
        assert result is not None
        return result


class AbstractFileDocumentable(AbstractDocumentable):
    """
    An abstract base class for Documentables that are also a single file
    (in the general sense).
    """
    def __init__(self, p: Pathname,
                 doc: Optional[ItemDocumentation] = None) -> None:
        """
        Initializes us with the pathname of our file and any documentation
        about us.
        """
        assert p is not None
        # 'doc' can be None
        super().__init__(os.path.basename(p), LinePosition(p, 1), doc)

    def pathname(self) -> Pathname:
        """
        Returns the pathname of the file that we represent.
        """
        result: Pathname = self.firstLinePosition().pathname()
        assert result is not None
        return result

    def isEntireFile(self) -> bool:
        return True

    def definitionStart(self) -> str:
        # Our definition is always at the start of our file.
        result: str = ""
        assert result is not None
        return result


class Script(AbstractFileDocumentable):
    """
    A standalone script (and not just a symbolic link to one).

    FUTURE: handle scripts in languages whose comment lines don't start with
    '#'.

    See also: ScriptLink.
    """
    # The name of this kind of documentable.
    _kindName: ClassVar[str] = "script"

    # The suffix that we append to an instance's name to get its formatted
    # typed name.
    #
    # See also: Dcoumentable.formattedTypedName().
    _typeSuffix: ClassVar[str] = "*"

    def kindName(self) -> str:
        result: str = self._kindName
        assert result
        return result

    def formattedTypedName(self) -> str:
        result: str = self.name() + self._typeSuffix
        assert result
        return result


class ScriptLink(AbstractFileDocumentable):
    """
    A symbolic link to a script.

    See also: Script.
    """
    # The name of this kind of documentable.
    _kindName: ClassVar[str] = "symbolic link to a script"

    # The suffix that we append to an instance's name to get its formatted
    # typed name.
    #
    # See also: Dcoumentable.formattedTypedName().
    _typeSuffix: ClassVar[str] = "@"

    def __init__(self, p: Pathname) -> None:
        """
        Initializes us with the pathname of our file.

        Note: there can't be any documentation about us.

        See also: maybeSetLinkedScript().
        """
        assert p is not None
        super().__init__(p)
        self._linkedScript: Optional[Script] = None
            # the Script that represents the script we're a link to, or None
            # if either it hasn't been set yet or the script we link to isn't
            # one that's documented

    def maybeSetLinkedScript(self, s: Script) -> bool:
        """
        Sets 's' to be the script that we're a symbolic link to iff it
        actually represents that file, returning True iff it does get set.
        """
        assert s is not None
        result: bool = False
        if s.pathname() == self._linkedScriptPathname():
            self._linkedScript = s
            result = True
        return result

    def kindName(self) -> str:
        result: str = self._kindName
        assert result
        return result

    def formattedTypedName(self) -> str:
        result: str = self.name() + self._typeSuffix
        assert result
        return result

    def doesRename(self) -> bool:
        return True

    def renamerKindDescription(self) -> str:
        assert self.doesRename()
        result: str = _scriptLinkRenamerKindDescription
        assert result is not None
        return result

    def renamedName(self) -> str:
        assert self.doesRename()
        result: str = os.path.basename(self._linkedScriptPathname())
        assert result
        return result

    def findUltimateRenamed(self) -> Optional[Documentable]:
        # 'result' can be None
        return self._linkedScript

    def _linkedScriptPathname(self) -> Pathname:
        """
        Returns the pathname of the script that we're a symlink to.
        """
        result: Pathname = os.path.realpath(self.pathname())
        assert result is not None
        return result


class DocumentableHolder(ABC):
    """
    The interface implemented by classes that can have Documentables added
    to them.
    """
    @abstractmethod
    def addRenamingAlias(self, d: RenamingAlias, rep: Reporter) -> bool:
        """
        Adds to us the renaming alias definition 'd', reporting any and
        all problems using 'rep' and returning True iff the alias was
        successfully added.
        """
        assert d is not None
        assert rep is not None
        pass

    @abstractmethod
    def addDefinedAlias(self, d: DefinedAlias, rep: Reporter) -> bool:
        """
        Adds to us the defined alias definition 'd', reporting any and all
        problems using 'rep' and returning True iff the alias was
        successfully added.
        """
        assert d is not None
        assert rep is not None
        pass

    @abstractmethod
    def addFunction(self, d: Function, rep: Reporter) -> bool:
        """
        Adds to us the shell function definition 'd', reporting any and all
        problems using 'rep' and returning True iff the function was
        successfully added.
        """
        assert d is not None
        assert rep is not None
        pass

    @abstractmethod
    def addScript(self, d: Script, rep: Reporter) -> bool:
        """
        Adds to us the script 'd', reporting any and all problems using 'rep'
        and returning True iff the script was successfully added.

        See also: addScriptLink().
        """
        assert d is not None
        assert rep is not None
        pass

    @abstractmethod
    def addScriptLink(self, d: ScriptLink, rep: Reporter) -> bool:
        """
        Adds to us the script link 'd', reporting any and all problems using
        'rep' and returning True iff the script link was successfully added.
        """
        assert d is not None
        assert rep is not None
        pass



T = TypeVar('T')

class Block(ABC):
    """
    An abstract base class for blocks of consecutive related lines in a file
    containing - we assume - bash alias and function definitions.
    """
    # The maximum number of Blocks that can be converted into Documentables
    # at one time.
    #
    # See also: convertToDocumentables().
    maxConvertible: ClassVar[int] = 2

    @classmethod
    def lineIndentSize(cls, line: str, pos: LinePosition) -> int:
        """
        Returns the number of consecutive spaces at the start of the 'line'
        that's assumed to be at position 'pos', or raises a
        TabInIndentationException if the whitespace at the start of 'line'
        contains one or more tab characters.
        """
        assert line is not None
        indent: str = cls.lineIndent(line)
        if _tab in indent:
            msg: str = _tabInIndentFmt.format(pos)
            raise TabInIndentationException(msg, pos)
        result: int = len(indent)
        assert result >= 0
        return result

    @staticmethod
    def lineIndent(line: str) -> str:
        """
        Returns all of the consecutive whitespace characters - that is, the
        indentation - at the start of 'line'.
        """
        assert line is not None
        sz: int = 0
        for ch in line:
            if not ch.isspace():
                break  # for
            sz += 1
        result: str = line[:sz]
        assert result is not None  # but it may be empty
        return result


    def __init__(self, firstLinePos: LinePosition) -> None:
        """
        Initializes us with the position of the first line in this block.
        """
        assert firstLinePos is not None
        pos: LinePosition = firstLinePos.copy()
        self._firstLinePos: LinePosition = pos
        self._lastLinePos: LinePosition = pos
        assert self._firstLinePos is not None
        assert self._lastLinePos is not None

    def firstLinePosition(self) -> LinePosition:
        """
        Returns the position of the first line in this block.
        """
        result: LinePosition = self._firstLinePos
        assert result is not None
        return result

    def lastLinePosition(self) -> LinePosition:
        """
        Returns the position of the last line in this block (so far).
        """
        result: LinePosition = self._lastLinePos
        assert result is not None
        return result

    def lineCount(self) -> int:
        """
        Returns the number of lines in this block (so far).
        """
        result: int = self._lastLinePos.lineNumber() - \
            self._firstLinePos.lineNumber() + 1
        assert result > 1
        return result


    def addLine(self, line: str, pos: LinePosition) -> None:
        """
        Adds the line 'line' at position 'pos' to the end of this block.
        """
        assert line is not None
        assert pos is not None
        # This default implementation intentionally ignores 'line'.
        self._lastLinePos = pos.copy()

    @abstractmethod
    def indentSize(self) -> int:
        """
        Returns the number of spaces that the lines in this block are
        considered to be indented.
        """
        pass
        #assert result >= 0


    def _checkItemDocumentationHasSummary(self, doc: ItemDocumentation,
                                          d: Documentable,
                                          rep: Reporter) -> bool:
        """
        Checks that the documentation 'doc' for the Documentable 'd' includes
        a summary, returning True if it does and reporting a warning using
        'rep' and returning False if it doesn't.
        """
        assert doc is not None
        assert d is not None
        assert rep is not None
        result: bool = True
        if not doc.summary():  # zero-Paragraph summary
            result = False
            rep.warnAt(d.firstLinePosition(), _missingSummaryFmt, d.name())
        return result

    def _addUndocumentedAliasTo(self, dest: DocumentableHolder,
                                code: 'AliasDefinitionBlock',
                                rep: Reporter) -> None:
        """
        Adds to 'dest' a Documentable that represents the undocumented alias
        whose definition 'code' represents and uses 'rep' to warn about the
        undocumented alias (and possibly other things).
        """
        assert dest is not None
        assert code is not None
        assert rep is not None
        # Renaming aliases don't need to be documented (though they can be),
        # but defined ones should be.
        name: str = code.name()
        pos: LinePosition = code.firstLinePosition()
        if code.isRenaming():
            dest.addRenamingAlias(RenamingAlias(name, code.renamedName(),
                                                pos), rep)
        else:
            d: DefinedAlias = DefinedAlias(name, pos)
            rep.warnAt(pos, _undocumentedAliasFmt, d.formattedName())
            dest.addDefinedAlias(d, rep)

    def _addDocumentedAliasTo(self, dest: DocumentableHolder,
                              code: 'AliasDefinitionBlock',
                              doc: 'CommentBlock', rep: Reporter) -> None:
        """
        Adds to 'dest' a Documentable that represents the documented alias
        whose definition 'code' represents and whose documentation 'doc'
        represents, using 'rep' to warn about any issues or problems (in the
        documentation, for example).
        """
        assert dest is not None
        assert code is not None
        assert doc is not None
        assert rep is not None
        itemDoc: ItemDocumentation = \
            ItemDocumentation.parseComments(doc, rep)
        pos: LinePosition = code.firstLinePosition()
        d: Documentable
        if code.isRenaming():
            d = RenamingAlias(code.name(), code.renamedName(), pos, itemDoc)
            dest.addRenamingAlias(d, rep)
        else:
            d = DefinedAlias(code.name(), pos, itemDoc)
            dest.addDefinedAlias(d, rep)
        self._checkItemDocumentationHasSummary(itemDoc, d, rep)
            # we only check for a missing summary on Documentables with
            # documentation so that we don't report two warnings for every
            # undocumented Documentable

    def _addUndocumentedFunctionTo(self, dest: DocumentableHolder,
                                   code: 'FunctionDefinitionBlock',
                                   rep: Reporter) -> None:
        """
        Adds to 'dest' a Function Documentable that represents the
        undocumented shell function whose definition 'code' represents and
        uses 'rep' to warn about the undocumented function (and possibly
        other things).
        """
        assert dest is not None
        assert code is not None
        assert rep is not None
        pos: LinePosition = code.firstLinePosition()
        name: str = code.name()
        f: Function = Function(name, pos)
        rep.warnAt(pos, _undocumentedFunctionFmt, f.formattedName())
            # reports the function as being undocumented
        dest.addFunction(f, rep)

    def _addDocumentedFunctionTo(self, dest: DocumentableHolder,
                                 code: 'FunctionDefinitionBlock',
                                 doc: 'CommentBlock', rep: Reporter) -> None:
        """
        Adds to 'dest' a Function Documentable that represents the documented
        shell function whose definition 'code' represents and whose
        documentation 'doc' represents, using 'rep' to warn about any issues
        or problems (in the documentation, for example).
        """
        assert dest is not None
        assert code is not None
        assert doc is not None
        assert rep is not None
        itemDoc: ItemDocumentation = \
            ItemDocumentation.parseComments(doc, rep)
        f: Function = Function(code.name(), code.firstLinePosition(),
                               itemDoc)
        dest.addFunction(f, rep)
        self._checkItemDocumentationHasSummary(itemDoc, f, rep)
            # we only check for a missing summary on Documentables with
            # documentation so that we don't report two warnings for every
            # undocumented Documentable


    @abstractmethod
    def convertToDocumentables(self: T, prev: T, dest: DocumentableHolder,
                               rep: Reporter) -> int:
        """
        Converts 'prev' - which is assumed to be the Block that immediately
        precedes us - and possibly us as well into zero or more Documentables
        that we then add to 'dest'. We return the number of Blocks that were
        converted: 0 if none were, 1 if 'prev' was and 2 if both 'prev' and
        us were.

        The Reporter 'rep' will be used to report any and all issues and/or
        problems that occur during the conversion.

        Note: we can 'convert' one or both Blocks into zero Documentables if
        we can determine that they can't possibly be part of something that
        we document.
        """
        assert prev is not None
        assert dest is not None
        assert rep is not None
        pass
        #assert result >= 0
        #assert result <= self.maxConvertible

    @abstractmethod
    def convertLastToDocumentables(self, dest: DocumentableHolder,
                                   rep: Reporter) -> None:
        """
        Converts us into zero or more Documentables that we then add to
        'dest', where we're the last block in a file or similar grouping.

        The Reporter 'rep' will be used to report any and all issues and/or
        problems that occur during the conversion.
        """
        assert dest is not None
        assert rep is not None
        pass

    @abstractmethod
    def _convertUsAndBlankLines(self, next: 'BlankLinesBlock',
                                dest: DocumentableHolder,
                                rep: Reporter) -> int:
        """
        Converts us and possibly 'next' - which is assumed to immediately
        follow us - into zero or more Documentables that we then add to
        'dest'. We return the number of Blocks that were converted: 0 if none
        were, 1 if 'prev' was and 2 if both 'prev' and us were.

        The Reporter 'rep' will be used to report any and all issues and/or
        problems that occur during the conversion.

        See also: convertToDocumentables().
        """
        assert next is not None
        assert dest is not None
        assert rep is not None
        pass
        #assert result >= 0
        #assert result <= self.maxConvertible

    @abstractmethod
    def _convertUsAndComments(self, next: 'CommentBlock',
                              dest: DocumentableHolder,
                              rep: Reporter) -> int:
        """
        Converts us and possibly 'next' - which is assumed to immediately
        follow us - into zero or more Documentables that we then add to
        'dest'. We return the number of Blocks that were converted: 0 if none
        were, 1 if 'prev' was and 2 if both 'prev' and us were.

        The Reporter 'rep' will be used to report any and all issues and/or
        problems that occur during the conversion.

        See also: convertToDocumentables().
        """
        assert next is not None
        assert dest is not None
        assert rep is not None
        pass
        #assert result >= 0
        #assert result <= self.maxConvertible

    @abstractmethod
    def _convertUsAndAlias(self, next: 'AliasDefinitionBlock',
                           dest: DocumentableHolder, rep: Reporter) -> int:
        """
        Converts us and possibly 'next' - which is assumed to immediately
        follow us - into zero or more Documentables that we then add to
        'dest'. We return the number of Blocks that were converted: 0 if none
        were, 1 if 'prev' was and 2 if both 'prev' and us were.

        The Reporter 'rep' will be used to report any and all issues and/or
        problems that occur during the conversion.

        See also: convertToDocumentables().
        """
        assert next is not None
        assert dest is not None
        assert rep is not None
        pass
        #assert result >= 0
        #assert result <= self.maxConvertible

    @abstractmethod
    def _convertUsAndFunction(self, next: 'FunctionDefinitionBlock',
                              dest: DocumentableHolder,
                              rep: Reporter) -> int:
        """
        Converts us and possibly 'next' - which is assumed to immediately
        follow us - into zero or more Documentables that we then add to
        'dest'. We return the number of Blocks that were converted: 0 if none
        were, 1 if 'prev' was and 2 if both 'prev' and us were.

        The Reporter 'rep' will be used to report any and all issues and/or
        problems that occur during the conversion.

        See also: convertToDocumentables().
        """
        assert next is not None
        assert dest is not None
        assert rep is not None
        pass
        #assert result >= 0
        #assert result <= self.maxConvertible

    @abstractmethod
    def _convertUsAndOtherCode(self, next: 'OtherCodeBlock',
                               dest: DocumentableHolder,
                               rep: Reporter) -> int:
        """
        Converts us and possibly 'next' - which is assumed to immediately
        follow us - into zero or more Documentables that we then add to
        'dest'. We return the number of Blocks that were converted: 0 if none
        were, 1 if 'prev' was and 2 if both 'prev' and us were.

        The Reporter 'rep' will be used to report any and all issues and/or
        problems that occur during the conversion.

        See also: convertToDocumentables().
        """
        assert next is not None
        assert dest is not None
        assert rep is not None
        pass
        #assert result >= 0
        #assert result <= self.maxConvertible


T = TypeVar('T')

class BlankLinesBlock(Block):
    """
    A block of consecutive blank lines, where a line is considered to be a
    blank line iff it only contains whitespace characters.
    """
    def indentSize(self) -> int:
        # Blank lines are never considered to be indented, even if they
        # start with spaces.
        return 0

    def convertToDocumentables(self, prev: Block, dest: DocumentableHolder,
                               rep: Reporter) -> int:
        assert prev is not None
        assert dest is not None
        assert rep is not None
        result: int = prev._convertUsAndBlankLines(self, dest, rep)
        assert result >= 0
        assert result <= self.maxConvertible
        return result

    def convertLastToDocumentables(self, dest: DocumentableHolder,
                                   rep: Reporter) -> None:
        assert dest is not None
        assert rep is not None
        # Blank lines at the end of a file can just be discarded.
        pass

    def _convertUsAndBlankLines(self: T, next: T, dest: DocumentableHolder,
                                rep: Reporter) -> int:
        assert next is not None
        assert dest is not None
        assert rep is not None
        # This and 'next' should have been combined into one BlankLinesBlock.
        pos: LinePosition = self.firstLinePosition()
        lineNum: int = next.firstLinePosition().lineNumber()
        msg: str = _consecutiveBlankLinesBlocksFmt.format(pos, lineNum)
        raise ParsingException(msg, pos)
        #assert result >= 0
        #assert result <= self.maxConvertible
        #return result

    def _convertUsAndComments(self, next: 'CommentBlock',
                              dest: DocumentableHolder,
                              rep: Reporter) -> int:
        assert next is not None
        assert dest is not None
        assert rep is not None
        # Just discard us: 'next' may document a function definition.
        result: int = 1
        assert result >= 0
        assert result <= self.maxConvertible
        return result

    def _convertUsAndAlias(self, next: 'AliasDefinitionBlock',
                           dest: DocumentableHolder, rep: Reporter) -> int:
        assert next is not None
        assert dest is not None
        assert rep is not None
        result: int = 1  # just discard us
        assert result >= 0
        assert result <= self.maxConvertible
        return result

    def _convertUsAndFunction(self, next: 'FunctionDefinitionBlock',
                              dest: DocumentableHolder,
                              rep: Reporter) -> int:
        assert next is not None
        assert dest is not None
        assert rep is not None
        # Report the function as being undocumented, add a Documentable for
        # the function to 'dest' and then discard both us and 'next'.
        self._addUndocumentedFunctionTo(dest, next, rep)
        result: int = 2
        assert result >= 0
        assert result <= self.maxConvertible
        return result

    def _convertUsAndOtherCode(self, next: 'OtherCodeBlock',
                               dest: DocumentableHolder,
                               rep: Reporter) -> int:
        assert next is not None
        assert dest is not None
        assert rep is not None
        # Just discard us: 'next' may still be needed.
        result: int = 1
        assert result >= 0
        assert result <= self.maxConvertible
        return result


class AbstractIndentedLikeFirstLineBlock(Block):
    """
    An abstract base class for Blocks whose indentation is the same as its
    first line's.
    """
    def __init__(self, firstLine: str, startPos: LinePosition) -> None:
        """
        Initializes us with the first line 'firstLine' in this block and the
        position of that line.

        See also: addLine().
        """
        assert firstLine
        assert startPos is not None
        super().__init__(startPos)
        self._indentSize: int = self.lineIndentSize(firstLine, startPos)
        assert self._indentSize >= 0

    def indentSize(self) -> int:
        result: int = self._indentSize
        assert result >= 0
        return result


T = TypeVar('T')

class CommentBlock(AbstractIndentedLikeFirstLineBlock):
    """
    A block of consecutive comment lines.

    For the sake of simplicity all of the lines in a comment block have to be
    indented the same number of spaces: if and when the next line is indented
    a different amount then it becomes the start of a new comment block.
    """
    def __init__(self, firstLine: str, startPos: LinePosition) -> None:
        """
        Initializes us with the first line 'firstLine' in this block and the
        position of that line.
        """
        assert firstLine
        assert startPos is not None
        super().__init__(firstLine, startPos)
        self._lines: List[str] = [firstLine]
        assert self._lines

    def __str__(self) -> str:
        result: str = "CommentBlock:" + _newline
        line: str
        for line in self.lines():
            result += line + _newline
        assert result is not None
        return result

    def lines(self) -> List[str]:
        """
        Returns a list of all of the lines in this block, in order.
        """
        result: List[str] = self._lines
        assert result
        return result

    def addLine(self, line: str, pos: LinePosition) -> None:
        assert line is not None
        assert pos is not None
        super().addLine(line, pos)
        self._lines.append(line)


    def convertLastToDocumentables(self, dest: DocumentableHolder,
                                   rep: Reporter) -> None:
        assert dest is not None
        assert rep is not None
        # Comments at the end of a file can just be discarded.
        pass

    def convertToDocumentables(self, prev: Block, dest: DocumentableHolder,
                               rep: Reporter) -> int:
        assert prev is not None
        assert dest is not None
        assert rep is not None
        result: int = prev._convertUsAndComments(self, dest, rep)
        assert result >= 0
        assert result <= self.maxConvertible
        return result

    def _convertUsAndBlankLines(self, next: BlankLinesBlock,
                                dest: DocumentableHolder,
                                rep: Reporter) -> int:
        assert next is not None
        assert dest is not None
        assert rep is not None
        # Discard us since we apparently don't document an alias (otherwise
        # this method wouldn't have gotten called) and 'next' indicates that
        # we don't document a function either. 'next' may still be needed.
        result: int = 1
        assert result >= 0
        assert result <= self.maxConvertible
        return result

    def _convertUsAndComments(self: T, next: T, dest: DocumentableHolder,
                              rep: Reporter) -> int:
        assert next is not None
        assert dest is not None
        assert rep is not None
        indentSz: int = self.indentSize()
        nextSz: int = next.indentSize()
        pos: LinePosition = self.firstLinePosition()
        nextPos: LinePosition = next.firstLinePosition()
        if nextSz > indentSz:
            # FUTURE: if it turns out that this never really happens then we
            # might want to change this to a warning.
            rep.noteAt(nextPos, _commentIndentedMoreThanPrecedingOneFmt,
                       nextPos, pos.lineNumber())
        elif nextSz == indentSz:
            #debug("indentSz = {}, nextSz = {}", indentSz, nextSz)
            #debug("curr: {}", self)
            #debug("next: {}", next)
            # Two consecutive comment blocks are indented the same amount:
            # they should have been combined into a single CommentBlock
            # instead.
            msg: str = _consecutiveCommentBlocksWithSameIndentFmt. \
                format(pos, nextPos.lineNumber())
            raise ParsingException(msg, pos)
        # Otherwise 'next' is indented less than us, which happens all the
        # time: e.g. a commented out alias definition right after a
        # documented alias definition

        # Discard us since we don't document anything, but keep 'next' since
        # it might.
        result: int = 1
        assert result >= 0
        assert result <= self.maxConvertible
        return result

    def _convertUsAndAlias(self, next: 'AliasDefinitionBlock',
                           dest: DocumentableHolder, rep: Reporter) -> int:
        assert next is not None
        assert dest is not None
        assert rep is not None
        # Just discard us since we apparently don't document a function or an
        # alias: otherwise this method wouldn't have gotten called. 'next' is
        # still needed, obviously.
        result: int = 1
        assert result >= 0
        assert result <= self.maxConvertible
        return result

    def _convertUsAndFunction(self, next: 'FunctionDefinitionBlock',
                              dest: DocumentableHolder,
                              rep: Reporter) -> int:
        assert next is not None
        assert dest is not None
        assert rep is not None
        # The combination of us and 'next' is a documented shell function
        # definition.
        self._addDocumentedFunctionTo(dest, next, self, rep)
        result: int = 2
        assert result >= 0
        assert result <= self.maxConvertible
        return result

    def _convertUsAndOtherCode(self, next: 'OtherCodeBlock',
                               dest: DocumentableHolder,
                               rep: Reporter) -> int:
        assert next is not None
        assert dest is not None
        assert rep is not None
        # Discard us since we apparently don't document an alias (otherwise
        # this method wouldn't have gotten called) and 'next' indicates that
        # we don't document a function either. 'next' may still be needed.
        result: int = 1
        assert result >= 0
        assert result <= self.maxConvertible
        return result


T = TypeVar('T')

class AliasDefinitionBlock(AbstractIndentedLikeFirstLineBlock):
    """
    A block of consecutive lines that together make up the definition of a
    bash alias.
    """
    # A string containing all of the characters that can be used to quote
    # an alias' value.
    _valueQuoteChars: ClassVar[str] = "'" + '"'

    @classmethod
    def parseStart(cls, firstLine: str, startPos: LinePosition,
                   rep: Reporter) -> Optional['AliasDefinitionBlock']:
        """
        Parses the first line 'firstLine' of an alias definition whose
        position in 'startPos' and returns an AliasDefinitionBlock that
        represents it if it's successfully parsed and None if it isn't
        (in which case one or more parsing errors are reported using 'rep').
        """
        #debug("---> AliasDefinitionBlock.parseStart({}, {}, rep)", firstLine, startPos)
        assert firstLine
        assert startPos is not None
        assert rep is not None
        txt: str = firstLine.strip()[len(Alias.keyword):].lstrip()
        sep: str = Alias.nameValueSeparator
        result: Optional['AliasDefinitionBlock'] = None
        if sep in txt:
            parts: List[str] = txt.split(sep, 1)
            sz: int = len(parts)
            if sz == 2:
                name: str = parts[0].strip()
                if not name:
                    rep.alertAt(startPos, _missingAliasNameFmt)
                    assert result is None
                else:
                    value: str = parts[1].strip()
                    renamed: Optional[str] = None
                    if value and (value[0] not in cls._valueQuoteChars):
                        # The alias has a value and it isn't quoted. Because
                        # it isn't quoted we can easily remove any comment
                        # from the end of it (where they're especially likely
                        # since if they're indented underneath it then we
                        # don't autogenerate its documentation).
                        parts = value.split()  # on whitespace
                        assert parts  # since 'value' isn't empty
                        renamed = parts[0]  # up to before first wspace char
                    result = AliasDefinitionBlock(firstLine, startPos, name,
                                                  renamed)
                    assert result is not None
            else:
                assert sz == 1
                rep.alertAt(startPos, _missingAliasValueFmt,
                            parts[0].strip())
                assert result is None
        else:
            rep.alertAt(startPos, _noNameValueSeparatorInAliasFmt, sep)
            assert result is None
        # 'result' can be None
        return result

    def __init__(self, firstLine: str, startPos: LinePosition,
                 name: str, renamedName: Optional[str]) -> None:
        """
        Initializes us with the first line 'firstLine' in this block and the
        position of that line, as well as the name 'name' of the alias and
        the name 'renamedName' of the alias, shell function, script or
        command that it aliases if it's a renaming alias, or None if it's a
        defined alias.

        See also: addLine(), parse().
        """
        assert firstLine
        assert startPos is not None
        assert name
        assert (renamedName is None) or renamedName
            # can be None but not empty
        super().__init__(firstLine, startPos)
        self._name: str = name
        self._renamedName: Optional[str] = renamedName

    def name(self) -> str:
        """
        Returns the name of the alias that we define.
        """
        result: str = self._name
        assert result
        return result

    def isRenaming(self) -> bool:
        """
        Returns True iff we represent the definition of a renaming alias:
        that is, an alias that just defines another name for an alias,
        script, etc.
        """
        return (self._renamedName is not None)

    def renamedName(self) -> str:
        """
        Returns the name of the alias, command, etc. that we rename, assuming
        we're a renaming alias.

        See also: isRenaming().
        """
        assert self.isRenaming()
        result: str = self._renamedName
        assert result is not None
        return result

    def convertLastToDocumentables(self, dest: DocumentableHolder,
                                   rep: Reporter) -> None:
        assert dest is not None
        assert rep is not None
        # We're obviously not followed by a comment block, so we represent an
        # undocumented alias definition.
        self._addUndocumentedAliasTo(dest, self, rep)

    def convertToDocumentables(self, prev: Block, dest: DocumentableHolder,
                               rep: Reporter) -> int:
        assert prev is not None
        assert dest is not None
        assert rep is not None
        result: int = prev._convertUsAndAlias(self, dest, rep)
        assert result >= 0
        assert result <= self.maxConvertible
        return result

    def _convertUsAndBlankLines(self, next: BlankLinesBlock,
                                dest: DocumentableHolder,
                                rep: Reporter) -> int:
        assert next is not None
        assert dest is not None
        assert rep is not None
        # 'next' indicates that we represent the definition of an
        # undocumented alias, so add a Documentable built from us and then
        # discard us. 'next' may still be needed.
        self._addUndocumentedAliasTo(dest, self, rep)
        result: int = 1
        assert result >= 0
        assert result <= self.maxConvertible
        return result

    def _convertUsAndComments(self, next: CommentBlock,
                              dest: DocumentableHolder,
                              rep: Reporter) -> int:
        assert next is not None
        assert dest is not None
        assert rep is not None
        result: int
        if next.indentSize() > self.indentSize():
            # 'next' is indented under us, so together they represent a
            # documented alias definition.
            self._addDocumentedAliasTo(dest, self, next, rep)
            result = 2  # discard both 'self' and 'next'
        else:
            # 'next' is *not* indented under us, and so it doesn't document
            # us. We represent an undocumented alias definition, but 'next'
            # may still be needed (and we don't use it).
            self._addUndocumentedAliasTo(dest, self, rep)
            result = 1  # discard 'self', keep 'next'
        pass
        assert result >= 0
        assert result <= self.maxConvertible
        return result

    def _convertUsAndAlias(self: T, next: T, dest: DocumentableHolder,
                           rep: Reporter) -> int:
        assert next is not None
        assert dest is not None
        assert rep is not None
        # We represent an undocumented alias definition since we're
        # immediately followed by another alias definition. 'next' is still
        # needed, obviously.
        self._addUndocumentedAliasTo(dest, self, rep)
        result: int = 1
        assert result >= 0
        assert result <= self.maxConvertible
        return result

    def _convertUsAndFunction(self, next: 'FunctionDefinitionBlock',
                              dest: DocumentableHolder,
                              rep: Reporter) -> int:
        assert next is not None
        assert dest is not None
        assert rep is not None
        # We're an undocumented alias definition and 'next' is an
        # undocumented function definition. Warn about both if and as
        # necessary, add a Documentable for each and then discard them.
        self._addUndocumentedAliasTo(dest, self, rep)
        self._addUndocumentedFunctionTo(dest, next, rep)
        result: int = 2
        assert result >= 0
        assert result <= self.maxConvertible
        return result

    def _convertUsAndOtherCode(self, next: 'OtherCodeBlock',
                               dest: DocumentableHolder,
                               rep: Reporter) -> int:
        assert next is not None
        assert dest is not None
        assert rep is not None
        # 'next' indicates that we represent the definition of an
        # undocumented alias, so add a Documentable built from us and then
        # discard us. 'next' may still be needed.
        self._addUndocumentedAliasTo(dest, self, rep)
        result: int = 1
        assert result >= 0
        assert result <= self.maxConvertible
        return result


T = TypeVar('T')

class FunctionDefinitionBlock(AbstractIndentedLikeFirstLineBlock):
    """
    A block of consecutive lines that together make up the definition of a
    bash shell function.
    """
    @classmethod
    def parseStart(cls, firstLine: str, startPos: LinePosition,
                   rep: Reporter) -> Optional['FunctionDefinitionBlock']:
        """
        Parses the first line 'firstLine' of a function definition whose
        position in 'startPos' and returns a FunctionDefinitionBlock that
        represents it if it's successfully parsed and None if it isn't
        (in which case one or more parsing errors are reported using 'rep').
        """
        assert firstLine
        assert startPos is not None
        assert rep is not None
        txt: str = firstLine.strip()[len(Function.keyword):].lstrip()
        sep: str = Function.argumentsStart
        result: Optional['FunctionDefinitionBlock'] = None
        if sep in txt:
            name: str = txt.split(sep, 1)[0]
            if not name:
                rep.alertAt(startPos, _missingFunctionNameFmt)
                assert result is None
            else:
                result = FunctionDefinitionBlock(firstLine, startPos, name)
                assert result is not None
        else:
            rep.alertAt(startPos, _noArgumentsInFunctionFmt, sep)
            assert result is None
        # 'result' can be None
        return result

    def __init__(self, firstLine: str, startPos: LinePosition,
                 name: str) -> None:
        """
        Initializes us with the first line 'firstLine' in this block and the
        position of that line, as well as the name 'name' of the function.

        See also: addLine(), parse().
        """
        assert firstLine
        assert startPos is not None
        assert name
        super().__init__(firstLine, startPos)
        self._name: str = name

    def name(self) -> str:
        """
        Returns the name of the function that we define.
        """
        result: str = self._name
        assert result
        return result


    def convertLastToDocumentables(self, dest: DocumentableHolder,
                                   rep: Reporter) -> None:
        assert dest is not None
        assert rep is not None
        # We wouldn't get called if we were preceded by a comment block, so
        # we represent an undocumented shell function definition.
        self._addUndocumentedFunctionTo(dest, self, rep)

    def convertToDocumentables(self, prev: Block, dest: DocumentableHolder,
                               rep: Reporter) -> int:
        assert prev is not None
        assert dest is not None
        assert rep is not None
        result: int = prev._convertUsAndFunction(self, dest, rep)
        assert result >= 0
        assert result <= self.maxConvertible
        return result

    def _convertUsAndBlankLines(self, next: BlankLinesBlock,
                                dest: DocumentableHolder,
                                rep: Reporter) -> int:
        assert next is not None
        assert dest is not None
        assert rep is not None
        # We wouldn't get called if 'next' was preceded by a comment block,
        # so we represent an undocumented function definition. 'next' may
        # still be needed, though.
        self._addUndocumentedFunctionTo(dest, self, rep)
        result: int = 1
        assert result >= 0
        assert result <= self.maxConvertible
        return result

    def _convertUsAndComments(self, next: CommentBlock,
                              dest: DocumentableHolder,
                              rep: Reporter) -> int:
        assert next is not None
        assert dest is not None
        assert rep is not None
        # We wouldn't get called if 'next' was preceded by a comment block,
        # so we represent an undocumented function definition. 'next' may
        # still be needed, though.
        self._addUndocumentedFunctionTo(dest, self, rep)
        result: int = 1
        assert result >= 0
        assert result <= self.maxConvertible
        return result

    def _convertUsAndAlias(self, next: AliasDefinitionBlock,
                           dest: DocumentableHolder, rep: Reporter) -> int:
        assert next is not None
        assert dest is not None
        assert rep is not None
        # We wouldn't get called if 'next' was preceded by a comment block,
        # so we represent an undocumented function definition. 'next' will
        # still be needed, obviously.
        self._addUndocumentedFunctionTo(dest, self, rep)
        result: int = 1
        assert result >= 0
        assert result <= self.maxConvertible
        return result

    def _convertUsAndFunction(self: T, next: T, dest: DocumentableHolder,
                              rep: Reporter) -> int:
        assert next is not None
        assert dest is not None
        assert rep is not None
        # We wouldn't get called if 'next' was preceded by a comment block,
        # so we represent an undocumented function definition. And 'next'
        # is preceded by us and not a comment block, so it's undocumented
        # too. Warn about and add a Documentable for each, then discard both
        # blocks.
        self._addUndocumentedFunctionTo(dest, self, rep)
        self._addUndocumentedFunctionTo(dest, next, rep)
        result: int = 2
        assert result >= 0
        assert result <= self.maxConvertible
        return result

    def _convertUsAndOtherCode(self, next: 'OtherCodeBlock',
                               dest: DocumentableHolder,
                               rep: Reporter) -> int:
        assert next is not None
        assert dest is not None
        assert rep is not None
        # We wouldn't get called if 'next' was preceded by a comment block,
        # so we represent an undocumented function definition. 'next' may
        # still be needed, though.
        self._addUndocumentedFunctionTo(dest, self, rep)
        result: int = 1
        assert result >= 0
        assert result <= self.maxConvertible
        return result


T = TypeVar('T')

class OtherCodeBlock(AbstractIndentedLikeFirstLineBlock):
    """
    A block of consecutive lines of code that isn't code that we want to
    process specially (like alias and shell function definitions).

    Note: the lines in one of these blocks don't have to be indented the same
    number of lines. We currently consider the indentation size of our first
    line to be the size of the entire block's indentation, though not for any
    particular reason other than simplicity, so that can be changed if we
    find a more useful value for it.
    """
    def convertLastToDocumentables(self, dest: DocumentableHolder,
                                   rep: Reporter) -> None:
        assert dest is not None
        assert rep is not None
        # Other code at the end of a file can just be discarded.
        pass

    def convertToDocumentables(self, prev: Block, dest: DocumentableHolder,
                               rep: Reporter) -> int:
        assert prev is not None
        assert dest is not None
        assert rep is not None
        result: int = prev._convertUsAndOtherCode(self, dest, rep)
        assert result >= 0
        assert result <= self.maxConvertible
        return result

    def _convertUsAndBlankLines(self, next: BlankLinesBlock,
                                dest: DocumentableHolder,
                                rep: Reporter) -> int:
        assert next is not None
        assert dest is not None
        assert rep is not None
        # Just discard us. 'next' may still be needed, though.
        result: int = 1
        assert result >= 0
        assert result <= self.maxConvertible
        return result

    def _convertUsAndComments(self, next: CommentBlock,
                              dest: DocumentableHolder,
                              rep: Reporter) -> int:
        assert next is not None
        assert dest is not None
        assert rep is not None
        # Just discard us. 'next' may still be needed, though.
        result: int = 1
        assert result >= 0
        assert result <= self.maxConvertible
        return result

    def _convertUsAndAlias(self, next: AliasDefinitionBlock,
                           dest: DocumentableHolder, rep: Reporter) -> int:
        assert next is not None
        assert dest is not None
        assert rep is not None
        # Just discard us. 'next' is still needed, obviously.
        result: int = 1
        assert result >= 0
        assert result <= self.maxConvertible
        return result

    def _convertUsAndFunction(self, next: FunctionDefinitionBlock,
                              dest: DocumentableHolder,
                              rep: Reporter) -> int:
        assert next is not None
        assert dest is not None
        assert rep is not None
        # 'next' represents an undocumented function definition (since it's
        # preceded by us instead of a comment block). We can just be
        # discarded.
        self._addUndocumentedFunctionTo(dest, next, rep)
        result: int = 2  # discard both us and 'next'
        assert result >= 0
        assert result <= self.maxConvertible
        return result

    def _convertUsAndOtherCode(self: T, next: T, dest: DocumentableHolder,
                               rep: Reporter) -> int:
        assert next is not None
        assert dest is not None
        assert rep is not None
        # This and 'next' should have been combined into one OtherCodeBlock.
        pos: LinePosition = self.firstLinePosition()
        lineNum: int = next.firstLinePosition().lineNumber()
        msg: str = _consecutiveOtherCodeBlocksFmt.format(pos, lineNum)
        raise ParsingException(msg, pos)
        #assert result >= 0
        #assert result <= self.maxConvertible
        #return result


class BlockParser:
    """
    Parses the lines read from a stream into zero or more Blocks.
    """
    @staticmethod
    def isCommentLine(line: str) -> bool:
        """
        Returns True iff 'line' is a comment line, indented or not.

        See also: isIndentedCommentLine(), isUnindentedCommentLine().
        """
        assert line is not None
        return line.lstrip().startswith(_commentStart)

    @staticmethod
    def isIndentedLine(line: str) -> bool:
        """
        Returns True iff 'line' is indented: that is, if it starts with one
        or more whitespace characters.

        Note: we can return True for blank lines too.
        """
        assert line is not None
        return line and line[0].isspace()

    @staticmethod
    def isUnindentedCommentLine(line: str) -> bool:
        """
        Returns True iff 'line' is an unindented bash comment line.

        See also: isCommentLine(), isIndentedCommentLine().
        """
        assert line is not None
        return line.startswith(_commentStart)

    @classmethod
    def isIndentedCommentLine(cls, line: str) -> bool:
        """
        Returns True iff 'line' is an indented comment line.

        See also: isCommentLine(), isUnindentedCommentLine().
        """
        assert line is not None
        # Note: if 'line' is a comment line then it must contain at least one
        # character.
        return cls.isCommentLine(line) and line[0].isspace()

    @staticmethod
    def isBlankLine(line: str) -> bool:
        """
        Returns True iff 'line' is a blank line: that is, a line that
        consists of nothing but whitespace characters.
        """
        assert line is not None
        return not line.strip()

    @classmethod
    def isAliasDefinitionStart(cls, line: str) -> bool:
        """
        Returns True iff 'line' is the first line of a bash alias definition.
        """
        assert line is not None
        #return cls._doesLineStartWithKeyword(_aliasKeyword, line)
        return (re.match(_aliasDefinitionStartRegex, line) is not None)

    @classmethod
    def isFunctionDefinitionStart(cls, line: str) -> bool:
        """
        Returns True iff 'line' is the first line of a bash shell function
        definition, where we assume that all such definitions start with the
        optional 'function' keyword.
        """
        assert line is not None
        return cls._doesLineStartWithKeyword(_functionKeyword, line)

    @staticmethod
    def _doesLineStartWithKeyword(keyword: str, line: str) -> bool:
        """
        Returns if the - after removing all leading whitespace - 'line'
        starts with the word 'keyword' followed by at least one whitespace
        character.
        """
        assert keyword  # may not be empty
        assert line is not None
        s = line.lstrip()
        return s.startswith(keyword) and s[len(keyword)].isspace()


    def __init__(self, r, f: Pathname, reporter: Reporter) -> None:
        """
        Initializes us with the readable stream whose contents we're to parse
        into blocks, the pathname 'f' of the file that 'r' is assumed to read
        from and the reporter to use to report any and all issues and
        problems found while parsing blocks.
        """
        assert r is not None
        assert f is not None
        assert reporter is not None
        self._stream = r
        self._nextLine: Optional[str] = None
        self._nextLinePos: LinePosition = LinePosition(f, 0)
        self._reporter: Reporter = reporter
        assert not self._nextLinePos.isValid()

    def parseNextBlock(self) -> Optional[Block]:
        """
        Parses the next lines read from our stream into a Block and returns
        it, or returns None if there are no more lines in that stream.
        """
        result: Optional[Block] = None
        while result is None:
            line: Optional[str] = self._nextLine
            if line is None:
                # We haven't started parsing our file or we've finished
                # parsing it. It's the latter (and maybe the former too if
                # the file is empty) if we can't read a line from '_stream'.
                line = self._readNextLine(self._stream)
                if line is None:
                    # There are no more lines left to parse.
                    break  # while
            assert line is not None
            result = self._parseBlock(line, self._stream)
            # 'result' can be None
        # 'result' can be None
        return result

    def _position(self) -> LinePosition:
        """
        Returns the position of the current line: that is, the last line that
        was read from our stream.
        """
        result: LinePosition = self._nextLinePos
        assert result is not None
        assert result.isValid()
        return result

    def _parseBlock(self, line: str, r) -> Block:
        """
        Parses the line 'line' and zero or more lines read from the stream
        'r' and returns the Block that represents them, or returns None if
        its contents are too incorrect.

        Note: _position() will give the position of 'line' until we read
        another line from our stream.
        """
        assert line is not None
        assert r is not None
        result: Optional[Block]
        if self.isBlankLine(line):
            result = self._parseBlankLinesBlock(line, r)
        elif self.isCommentLine(line):
            result = self._parseCommentBlock(line, r)
        elif self.isAliasDefinitionStart(line):
            result = self._parseAliasDefinitionBlock(line, r)
        elif self.isFunctionDefinitionStart(line):
            result = self._parseFunctionDefinitionBlock(line, r)
        else:
            # It's code since it's not a comment line or blank line, and
            # it's other code since it's not something we're interested
            # in handling specially.
            result = self._parseOtherCodeBlock(line, r)
        # 'result' can be None
        return result

    def _warn(self, pos: LinePosition, fmt: str, *args) -> None:
        """
        Reports a warning built from the position 'pos' where the thing being
        warned about occurred, the format string 'fmt' and the arguments in
        'args'.
        """
        assert pos is not None
        assert fmt
        self._reporter.warnAt(pos, fmt, *args)

    def _readNextLine(self, r) -> Optional[str]:
        """
        Reads the next line from the readable stream 'r' and returns it
        (without any newline at the end of it), or sets '_nextLine' to None
        and returns None if there is no next line.
        """
        assert r is not None
        result: Optional[str] = readNextLineFrom(r, self._nextLinePos)
        if result is None:
            self._nextLine = None
        # 'result' can be None
        return result


    def _parseBlankLinesBlock(self, line: str, r) -> BlankLinesBlock:
        """
        Returns the block of consecutive blank lines starting with 'line'
        followed by zero or more lines read from 'r'.
        """
        assert line is not None
        assert self.isBlankLine(line)
        assert r is not None
        result: BlankLinesBlock = BlankLinesBlock(self._position())
        while True:
            nextLine: str = self._readNextLine(r)
            if nextLine is None:
                break  # while
            if self.isBlankLine(nextLine):
                result.addLine(nextLine, self._position())
            else:
                self._nextLine = nextLine
                break  # while
        assert result is not None
        return result

    def _parseCommentBlock(self, line: str, r) -> CommentBlock:
        """
        Returns the block of consecutive comment lines starting with 'line'
        and followed by zero or more lines read from 'r', where all of the
        lines are indented the same amount.
        """
        assert line is not None
        assert self.isCommentLine(line)
        assert r is not None
        result: CommentBlock = CommentBlock(line, self._position())
        indentSz: int = result.indentSize()
        while True:
            nextLine: str = self._readNextLine(r)
            if nextLine is None:
                break  # while
            pos: LinePosition = self._position()
            if self.isCommentLine(nextLine) and \
               result.lineIndentSize(nextLine, pos) == indentSz:
                result.addLine(nextLine, pos)
            else:
                self._nextLine = nextLine
                break  # while
        assert result is not None
        return result

    def _parseOtherCodeBlock(self, line: str, r) -> OtherCodeBlock:
        """
        Returns the block of lines starting with 'line' and followed by zero
        or more lines read from 'r' that aren't blank lines or comment lines,
        but also aren't code that we're interested in handling specially.
        """
        assert line is not None
        assert r is not None
        result: OtherCodeBlock = OtherCodeBlock(line, self._position())
        while True:
            nextLine: str = self._readNextLine(r)
            if nextLine is None:
                break  # while
            if self.isCommentLine(nextLine) or \
               self.isBlankLine(nextLine) or \
               self.isAliasDefinitionStart(nextLine) or \
               self.isFunctionDefinitionStart(nextLine):
                # 'nextLine' is the start of something we're interested in.
                self._nextLine = nextLine
                break  # while
            else:
                result.addLine(nextLine, self._position())
        assert result is not None
        return result

    def _parseAliasDefinitionBlock(self, line: str,
                                   r) -> Optional[AliasDefinitionBlock]:
        """
        Returns the block of lines starting with 'line' and followed by zero
        or more lines read from 'r' that make up a bash alias definition, or
        returns None if the alias definition is too incorrect to parse
        successfully.
        """
        assert line is not None
        assert self.isAliasDefinitionStart(line)
        assert r is not None
        # For now we assume that alias definitions always consist of exactly
        # one physical line.
        #
        # FUTURE: handle alias definitions that are split across more than
        # one physical line *iff* each line other than the last one ends with
        # a backslash followed by zero or more whitespace characters. (We
        # don't - and won't - attempt to handle lines with a comment after
        # the backslash since we'd have to be sure that the '#' wasn't
        # actually inside a string, for example, which is way more parsing
        # than I'm willing to do here.)
        result: Optional[AliasDefinitionBlock] = \
            AliasDefinitionBlock.parseStart(line, self._position(),
                                            self._reporter)
        self._nextLine = self._readNextLine(r)
        # 'result' can be None
        return result

    def _parseFunctionDefinitionBlock(self, line: str,
                                      r) -> FunctionDefinitionBlock:
        """
        Returns the block of lines starting with 'line' and followed by zero
        or more lines read from 'r' that make up a bash (shell) function
        definition.
        """
        assert line is not None
        assert self.isFunctionDefinitionStart(line)
        assert r is not None
        startPos: LinePosition = self._position().copy()  # of first line
        result: FunctionDefinitionBlock = FunctionDefinitionBlock. \
            parseStart(line, startPos, self._reporter)

        # Note: 'result' may be None (but we parse the rest of its definition
        # regardless).
        indentSz: int = Block.lineIndentSize(line, startPos)
        while True:
            nextLine: str = self._readNextLine(r)
            if nextLine is None:
                break  # while
            pos = self._position()
            if result is not None:
                result.addLine(nextLine, pos)
            sz: int = Block.lineIndentSize(nextLine, pos)
            if (sz <= indentSz) and \
               nextLine.lstrip().startswith(_closingBrace):
                # We assume 'nextLine' is the last line of the function
                # definition since it starts with a closing brace that's
                # indented the same amount or less than the first line of
                # our definition. (It could be in a here document or
                # something, but we don't handle that sort of thing and so
                # assume that it won't happen: see the Limitations section
                # of our top comment.)
                self._nextLine = self._readNextLine(r)  # may be None
                break
            elif self.isAliasDefinitionStart(nextLine):
                # Our heuristic for finding the end of a function definition
                # is less than foolproof, so we warn about anything that
                # looks like an alias definition within one in case we've
                # mistakenly included too much code in it.
                self._warn(pos, _possibleAliasInFunctionFmt,
                           startPos.lineNumber())
            elif self.isFunctionDefinitionStart(nextLine):
                # Our heuristic for finding the end of a function definition
                # is less than foolproof, so we warn about anything that
                # looks like another function definition within one in case
                # we've mistakenly included too much code in it.
                self._warn(pos, _possibleFunctionInFunctionFmt,
                           startPos.lineNumber())
        # 'result' can be None
        return result


class Documentation(ABC):
    """
    A base class for classes that represent the documentation of all of the
    Documentable items in all of the files we've processed.

    Subclasses usually override our write() method to write out this
    documentation in a particular format.
    """
    def __init__(self, sources: DocumentablesSources,
                 renamingAliases: Dict[str, RenamingAlias],
                 definedAliases: Dict[str, DefinedAlias],
                 functions: Dict[str, Function],
                 scripts: Dict[str, Script],
                 scriptLinks: Dict[str, ScriptLink], rep: Reporter) -> None:
        """
        Initializes us from the specified information, including the Reporter
        to use to report any and all notes, warnings, etc.
        """
        assert sources is not None
        assert not sources.isEmpty()
        assert renamingAliases is not None
        assert definedAliases is not None
        assert functions is not None
        assert scripts is not None
        assert scriptLinks is not None
        assert rep is not None
        self.sources: DocumentablesSources = sources
        self.renamingAliases: Dict[str, RenamingAlias] = renamingAliases
            # maps the names of renaming aliases to the aliases themselves
        self.definedAliases: Dict[str, DefinedAlias] = definedAliases
            # maps the names of defined aliases to the aliases themselves
        self.functions: Dict[str, Function] = functions
            # maps the names of shell functions to the functions themselves
        self.scripts: Dict[str, Script] = scripts
            # maps the (base)names of scripts to the scripts themselves
        self.scriptLinks: Dict[str, ScriptLink] = scriptLinks
            # maps the (base)names of links to scripts to the links
            # themselves
        self._reporter: Reporter = rep

    def findDocumentable(self, name: str) -> Optional[Documentable]:
        """
        Returns the Documentable named 'name' or None if we don't have one
        with that name. Aliases are returned in preference to functions,
        functions are returned in preference to scripts and scripts are
        returned in preference to script links.

        See also: findAlias(), findFunction(), findScript(),
        findScriptLink().
        """
        assert name is not None
        result: Optional[Documentable] = self.findAlias(name) or \
            self.findFunction(name) or self.findScript(name) or \
            self.findScriptLink(name)
        # 'result' can be None
        return result

    def findAlias(self, name: str) -> Optional[Alias]:
        """
        Returns the Alias named 'name' or None if we don't have one with that
        name.

        See also: findFunction(), findDocumentable().
        """
        assert name is not None
        result: Optional[Alias] = self.renamingAliases.get(name)
        if result is None:
            result = self.definedAliases.get(name)
        # 'result' can be None
        return result

    def findFunction(self, name: str) -> Optional[Function]:
        """
        Returns the Function named 'name' or None if we don't have one with
        that name.

        See also: findAlias(), findDocumentable().
        """
        assert name is not None
        result: Optional[Function] = self.functions.get(name)
        # 'result' can be None
        return result

    def findScript(self, name: str) -> Optional[Script]:
        """
        Returns the Script named 'name' or None if we don't have one with
        that name.

        See also: findAlias(), findFunction(), findDocumentable().
        """
        assert name is not None
        result: Optional[Script] = self.scripts.get(name)
        # 'result' can be None
        return result

    def findScriptLink(self, name: str) -> Optional[ScriptLink]:
        """
        Returns the ScriptLink named 'name' or None if we don't have one with
        that name.

        See also: findAlias(), findFunction(), findDocumentable().
        """
        assert name is not None
        result: Optional[ScriptLink] = self.scriptLinks.get(name)
        # 'result' can be None
        return result


    def allDocumentables(self) -> Documentable:
        """
        Yields all of the Documentables that we document in the order that
        they usually appear in our documentation when they're ordered.
        """
        iter: OrderedDocumentablesIterator = \
            CaselessAlphabeticalNamesDocumentablesIterator(self)
        result: Documentable
        for result in iter.all():
            assert result is not None
            yield result

    def allButRenamingDocumentables(self) -> Documentable:
        """
        Yields - in the order that they usually appear in our documentation
        when they're ordered - all of the Documentables that we document
        except any that rename one or more other Documentables.
        """
        iter: OrderedDocumentablesIterator = \
            CaselessAlphabeticalNamesDocumentablesIterator(self)
        result: Documentable
        for result in iter.withoutRenaming():
            assert result is not None
            yield result

    def allButUndocumentedRenamingDocumentables(self) -> Documentable:
        """
        Yields - in the order that they usually appear in our documentation
        when they're ordered - all of the Documentables that we document
        except any that both are documented and rename one or more other
        Documentables .
        """
        iter: OrderedDocumentablesIterator = \
            CaselessAlphabeticalNamesDocumentablesIterator(self)
        result: Documentable
        for result in iter.withoutUndocumentedRenaming():
            assert result is not None
            yield result

    @abstractmethod
    def writeDocument(self, w) -> None:
        """
        Writes this documentation to the writable stream 'w'.
        """
        assert w is not None
        pass

    def _write(self, w, fmt: str, *args, **kwargs) -> None:
        """
        Writes out to 'w' the message built from the format string 'fmt' and
        the arguments 'args' and 'kwargs'.

        See also: _writeLine().
        """
        assert w is not None
        assert fmt is not None
        if (not args) and (not kwargs):
            # Don't call format() so that it doesn't misinterpret things
            # that look like they're special to it (e.g. '{}'). This allows
            # us to be used to output text verbatim.
            w.write(fmt)
        else:
            w.write(fmt.format(*args, **kwargs))

    def _writeLine(self, w, fmt: Optional[str] = None, *args,
                   **kwargs) -> None:
        """
        Writes out to 'w' the message built from the format string 'fmt' and
        the arguments 'args' and 'kwargs', followed by a newline. If 'fmt'
        is None then just a newline is written to 'w'.

        See also: _write().
        """
        assert w is not None
        # 'fmt' can be None
        if fmt is not None:
            self._write(w, fmt, *args, **kwargs)
        w.write(_newline)


    def _noteAt(self, pos: LinePosition, fmt: str, *args) -> None:
        """
        See: Reporter.noteAt().
        """
        assert pos is not None
        assert fmt
        self._reporter.noteAt(pos, fmt, *args)

    def _warnAt(self, pos: LinePosition, fmt: str, *args) -> None:
        """
        See: Reporter.warnAt().
        """
        assert pos is not None
        assert fmt
        self._reporter.warnAt(pos, fmt, *args)


class OrderedDocumentablesIterator(ABC):
    """
    A base class for classes that allow you to iterate over all of the
    Documentables that a Documentation instance documents in a specific
    order.
    """
    @staticmethod
    def _areAllEmpty(*cs) -> bool:
        """
        Returns True iff all of the containers in 'cs' are empty.
        """
        result: bool = True
        for c in cs:
            if c:
                result = False
                break  # for
        return result


    def __init__(self, doc: 'Documentation') -> None:
        """
        Initializes us with the Documentation whose Documentables we iterate
        over.
        """
        assert doc is not None
        self._documentation = doc

    def all(self) -> Documentable:
        """
        Yields all of the Documentables in our Documentation, in order.

        See also: withoutRenaming(), withoutUndocumentedRenaming(),
        _documentables().
        """
        #debug("---> OrderedDocumentablesIterator.all() ...")
        doc: Documentation = self._documentation
        ranames: List[str] = \
            self._toReverseSortedNameLists(doc.renamingAliases)
        danames: List[str] = \
            self._toReverseSortedNameLists(doc.definedAliases)
        funames: List[str] = self._toReverseSortedNameLists(doc.functions)
        scnames: List[str] = self._toReverseSortedNameLists(doc.scripts)
        slnames: List[str] = self._toReverseSortedNameLists(doc.scriptLinks)
        result: Documentable
        for result in self._documentables(ranames, danames, funames,
                                          scnames, slnames):
            assert result is not None
            yield result

    def withoutRenaming(self) -> Documentable:
        """
        Yields all of the Documentables in our Documentation, in order,
        except for all of the RenamingAliases that rename at least one
        Documentable (and not just things we don't document, like scripts or
        binaries).

        See also: all(), withoutUndocumentedRenaming(), _documentables().
        """
        #debug("---> OrderedDocumentablesIterator.withoutRenaming() ...")
        doc: Documentation = self._documentation

        # Only include names of the RenamingAliases without a renaming chain
        # (since those with such a chain rename at least one Documentable).
        ra: Dict[str, RenamingAlias] = doc.renamingAliases
        ranames: List[str] = self._toReverseSortedNameLists(ra)
        ranames = [nm for nm in ranames
                   if ra[nm].findUltimateRenamed() is None]

        danames: List[str] = \
            self._toReverseSortedNameLists(doc.definedAliases)
        funames: List[str] = self._toReverseSortedNameLists(doc.functions)
        scnames: List[str] = self._toReverseSortedNameLists(doc.scripts)
        slnames: List[str] = self._toReverseSortedNameLists(doc.scriptLinks)
        result: Documentable
        for result in self._documentables(ranames, danames, funames,
                                          scnames, slnames):
            assert result is not None
            yield result

    def withoutUndocumentedRenaming(self) -> Documentable:
        """
        Yields all of the Documentables in our Documentation, in order,
        except for all of the RenamingAliases that both rename at least one
        Documentable (and not just things we don't document, like scripts or
        binaries) and are documented.

        See also: all(), withoutRenaming(), _documentables().
        """
        #debug("---> OrderedDocumentablesIterator.withoutUndocumentedRenaming() ...")
        doc: Documentation = self._documentation

        # Only include RenamingAliases if they have their own documentation
        # or they don't just rename another Documentable (since if they do
        # rename one then the full description of the Documentable that they
        # rename is used as their full description too).
        ra: Dict[str, RenamingAlias] = doc.renamingAliases
        ranames: List[str] = self._toReverseSortedNameLists(ra)
        ranames = [nm for nm in ranames if
                   (ra[nm].hasDocumentation() or
                    (ra[nm].findUltimateRenamed() is None))]
        danames: List[str] = \
            self._toReverseSortedNameLists(doc.definedAliases)
        funames: List[str] = self._toReverseSortedNameLists(doc.functions)
        scnames: List[str] = self._toReverseSortedNameLists(doc.scripts)
        slnames: List[str] = self._toReverseSortedNameLists(doc.scriptLinks)
        result: Documentable
        for result in self._documentables(ranames, danames, funames,
                                          scnames, slnames):
            assert result is not None
            yield result

    def _documentables(self, ranames: List[str], danames: List[str],
                       funames: List[str], scnames: List[str],
                       slnames: List[str]) -> Documentable:
        """
        Yields, in order,

          - all of the RenamingAliases in our Documentation whose names are
            in 'ranames',
          - all of the DefinedAliases in our Documentation whose names are
            in 'danames',
          - all of the Functions in our Documentation whose names are in
            'funames', and
          - all of the Scripts in our Documentation whose names are in
            'scnames'
          - all of the ScriptLinks in our Documentation whose names are in
            'slnames'
        where all of the lists are assumed to be sorted using our ordering.

        Note: we will modify all of the lists.
        """
        #debug("---> OrderedDocumentablesIterator._documentables() ...")
        keyFn = self._noneOrDocumentableNameToSortKey
        allLists: List[List[str]] = [ranames, danames, funames, scnames,
                                     slnames]
        while not self._areAllEmpty(*allLists):
            #debug("    are still Documentables ...")
            lasts: List[str] = []
            c: List[str]
            for c in allLists:
                if c:
                    lasts.append(c[-1])
            assert lasts  # since at least one list is non-empty
            lasts.sort(key = keyFn)

            # When they have the same name we yield alias before functions,
            # functions before scripts and scripts before script links. This
            # isn't particularly important, though.
            #
            # Note: we remove a name from exactly one list, but remove
            # *nothing* from the dicts.
            doc: Documentation = self._documentation
            name: str = lasts[0]
            #debug("    resulting Documentable's name: [{}]", name)
            result: Documentable
            if ranames and ranames[-1] == name:
                result = doc.renamingAliases[ranames.pop()]
            elif danames and danames[-1] == name:
                result = doc.definedAliases[danames.pop()]
            elif funames and funames[-1] == name:
                result = doc.functions[funames.pop()]
            elif scnames and scnames[-1] == name:
                result = doc.scripts[scnames.pop()]
            else:
                assert slnames and slnames[-1] == name
                result = doc.scriptLinks[slnames.pop()]
            assert result is not None
            yield result

    def _toReverseSortedNameLists(self,
                                  m: Dict[str, Documentable]) -> List[str]:
        """
        Given a dict 'm' that maps Documentable names to the Documentables
        themselves, returns a list of the names of all of those Documentables
        sorted in the reverse order that we yield Documentables.

        Note: we sort them in reverse order since removing items from the end
        of a list should be considerably cheaper than removing them from the
        beginning.
        """
        assert m is not None
        result: List[str] = list(m)
        result.sort(key = self._noneOrDocumentableNameToSortKey,
                    reverse = True)
        assert result is not None
        return result

    def _noneOrDocumentableNameToSortKey(self, name: str) -> str:
        """
        The sort key method that converts None (to None) and converts
        Documentable names to the keys to use to sort Documentable in the
        order that we're to iterate over them.
        """
        # 'name' can be None
        result: str = None
        if name is not None:
            result = self._documentableNameToSortKey(name)
            assert result is not None
        assert (name is None) == (result is None)
        return result

    @abstractmethod
    def _documentableNameToSortKey(self, name: str) -> str:
        """
        The sort key function/method that converts Documentable names to
        the keys to use to sort Documentables in the order that we're to
        iterate over them.
        """
        #assert name is not None
        pass
        #assert result is not None


class CaselessAlphabeticalNamesDocumentablesIterator(
        OrderedDocumentablesIterator):
    """
    Represents OrderedDocumentablesIterators that yield Documentables in
    alphabetical order by their names, ignoring any differences in case.
    """
    def _documentableNameToSortKey(self, name: str) -> str:
        assert name is not None
        result: str = name.lower()
        assert result is not None
        return result


class OrgModeFragmentFactory(ABC):
    """
    Represents a factory that creates various types of fragments of org mode
    documents.

    Note: the org mode documentation seems to refer to the two part of an
    org mode (hyper)link as the link and the description, the first of which
    is clearly ripe for confusion. Thus we use the term 'reference' for the
    link part of an org mode (hyper)link.

    References: the 'Hyperlinks' section of the org mode info documentation.
    """

    # The formats to use to alter the appearance and/or meaning of text in
    # an org mode document.
    _boldFmt: ClassVar[str] = "*{}*"
    _italicFmt: ClassVar[str] = "/{}/"
    _verbatimFmt: ClassVar[str] = "={}="
    _codeFmt: ClassVar[str] = "~{}~"

    # The formats to use to create org mode hyperlinks with or without
    # explicit descriptions.
    _describedLinkFmt: ClassVar[str] = "[[{}][{}]]"
    _undescribedLinkFmt: ClassVar[str] = "[[{}]]"

    # The format to use to make a reference from a CUSTOM_ID.
    _customIdToReferenceFmt: ClassVar[str] = "#{}"

    # The format to use to make a reference that searches for the specified
    # text in the current document.
    _searchTextReferenceFmt: ClassVar[str] = "{}"

    # The prefix to prepend to a pathname to make it (the start of) a local
    # file reference.
    _filePrefix: ClassVar[str] = "file:"

    # The formats to use to make references to (locations in) a local file.
    _fileReferenceFmt: ClassVar[str] = _filePrefix + "{}"
    _fileLineReferenceFmt: ClassVar[str] = _filePrefix + "{}::{}"
    _fileSearchReferenceFmt: ClassVar[str] = _filePrefix + "{}::{}"
        # same as _fileLineReferenceFmt: presumably one just can't search for
        # a sequence of digits?
    _fileHeadingSearchReferenceFmt: ClassVar[str] = _filePrefix + "{}::*{}"

    def makeDocumentableFileLink(self, f: Pathname) -> str:
        """
        Returns the org mode document fragment representing a link to the
        absolute pathname 'f', which is assumed to be the pathname of an
        entire Documentable or of the file that contains a Documentable.

        See also: LinePosition.displayablePathname(),
        _documentablePositionLink().
        """
        assert f is not None
        assert os.path.isabs(f)
        result: str = self.makeLink(self.makeAbsoluteFileReference(f),
                                    LinePosition.displayablePathname(f))
        assert result
        return result


    def makeBold(self, txt: str) -> str:
        """
        Returns the org mode fragment that makes the text 'txt' appear in a
        bold font.

        See also: makeItalic(), makeVerbatim(), makeCode().
        """
        assert txt
        result: str = self._boldFmt.format(txt)
        assert result
        return result

    def makeItalic(self, txt: str) -> str:
        """
        Returns the org mode fragment that makes the text 'txt' appear in a
        italic font.

        See also: makeBold(), makeVerbatim(), makeCode().
        """
        assert txt
        result: str = self._italicFmt.format(txt)
        assert result
        return result

    def makeVerbatim(self, txt: str) -> str:
        """
        Returns the org mode fragment that makes the text 'txt' appear as
        verbatim text.

        See also: makeBold(), makeItalic(), makeCode().
        """
        assert txt
        result: str = self._verbatimFmt.format(txt)
        assert result
        return result

    def makeCode(self, txt: str) -> str:
        """
        Returns the org mode fragment that makes the text 'txt' appear as
        computer source code.

        See also: makeBold(), makeItalic(), makeVerbatim().
        """
        assert txt
        result: str = self._codeFmt.format(txt)
        assert result
        return result


    def makeLink(self, ref: str, desc: Optional[str] = None) -> str:
        """
        Returns the org mode link whose reference part is 'ref' and whose
        description part is 'desc' unless 'desc' is None, in which case its
        description part is also 'ref'.
        """
        assert ref
        # 'desc' can be None
        result: str
        if desc is not None:
            result = self._describedLinkFmt.format(ref, desc)
        else:
            result = self._undescribedLinkFmt.format(ref)
        assert result is not None
        return result

    def makeIdReference(self, customId: str) -> str:
        """
        Returns the reference part of an org mode link that links to the
        section of the current document with CUSTOM_ID 'customId'.
        """
        assert customId
        result: str = self._customIdToReferenceFmt.format(customId)
        assert result
        return result

    def makeSearchReference(self, searchText: str) -> str:
        """
        Returns the reference part of an org mode link that searches for the
        text 'searchText' in the current file.

        See also: makeFileSearchReference().
        """
        assert searchText
        result: str = self._searchTextReferenceFmt.format(searchText)
        assert result
        return result

    def makeFileReference(self, f: Pathname) -> str:
        """
        Returns the reference part of an org mode link to the local file with
        pathname 'f', where 'f' can be a relative or absolute pathname.

        See also: makeAbsoluteFileReference().
        """
        assert f
        result: str = self._fileReferenceFmt.format(f)
        assert result
        return result

    def makeAbsoluteFileReference(self, f: Pathname) -> str:
        """
        Returns the reference part of an org mode link to the local file with
        absolute pathname 'f'.

        Note: our result will always be the same as makeFileReference()'s: we
        just ensure that 'f' is indeed an absolute pathname.

        See also: makeFileReference().
        """
        assert f
        assert os.path.isabs(f)
        result: str = self.makeFileReference(f)
        assert result
        return result

    def makeFileLineReference(self, f: Pathname, lineNum: int) -> str:
        """
        Returns the reference part of an org mode link to the line with
        (1-based) line number 'lineNum' in the local file with pathname 'f'.
        """
        assert f
        assert lineNum >= 1
        result: str = self._fileLineReferenceFmt.format(f, lineNum)
        assert result
        return result

    def makeFileSearchReference(self, f: Pathname, searchText: str) -> str:
        """
        Returns the reference part of an org mode link that searches for the
        text 'searchText' in the local file with pathname 'f'.

        See also: makeSearchReference(), makeFileHeadingSearchReference().
        """
        assert f
        assert searchText
        result: str = self._fileSearchReferenceFmt.format(f, searchText)
        assert result
        return result

    def makeFileHeadingSearchReference(self, f: Pathname,
                                       searchText: str) -> str:
        """
        Returns the reference part of an org mode link that searches for the
        text 'searchText' in headings in the local file with pathname 'f'.

        See also: makeSearchReference(), makeFileSearchReference().
        """
        assert f
        assert searchText
        result: str = self._fileHeadingSearchReferenceFmt.format(f,
                                                                 searchText)
        assert result
        return result


class PersonalOrgModeFragmentFactory(OrgModeFragmentFactory):
    """
    Represents an OrgModeFragmentFactory that creates fragments in a manner
    customized to my personal environment and setup.

    In particular whenever possible when it creates links to local files
    (like scripts) it creates links to the corresponding section of the
    appropriate scripts.org file.
    """
    # The basename of the 'scripts.org' file that we create links to sections
    # of if and when possible and appropriate.
    #
    # See also: _scriptsOrgBasename.
    _orgFileBasename: ClassVar[str] = _scriptsOrgBasename

    def makeDocumentableFileLink(self, f: Pathname) -> str:
        assert f is not None
        assert os.path.isabs(f)
        d: Pathname = f
        if not os.path.isdir(d):
            d = os.path.dirname(f)
        orgFile: Pathname = os.path.join(d, self._orgFileBasename)
        result: str
        if os.path.isfile(os.path.realpath(orgFile)):
            # The scripts.org file in the same directory as 'f' (or in 'f' if
            # 'f' is itself a directory) exists and is a regular file (or a
            # sequence of one or more symbolic links that eventually link to
            # a regular file).
            ref: str = os.path.basename(f)
            ref = self.makeFileHeadingSearchReference(orgFile, ref)
            result: str = self.makeLink(ref,
                                        LinePosition.displayablePathname(f))
        else:
            # The scripts.org file doesn't exist, so return the default link.
            result = super().makeDocumentableFileLink(f)
        assert result
        return result


class OrgModeDocumentation(Documentation):
    """
    The class of Documentation that can generate an org mode document.
    """
    # The format of the org mode CUSTOM_ID for the subsection of the
    # 'Descriptions' section that describes a given Documentable.
    #
    # See also: Documentable.id().
    _documentableDescriptionIdFmt: ClassVar[str] = "{}-description"

    def __init__(self, fact: OrgModeFragmentFactory,
                 sources: DocumentablesSources,
                 renamingAliases: Dict[str, RenamingAlias],
                 definedAliases: Dict[str, DefinedAlias],
                 functions: Dict[str, Function],
                 scripts: Dict[str, Script],
                 scriptLinks: Dict[str, ScriptLink], rep: Reporter) -> None:
        """
        Initializes us from the specified information, including the
        OrgModeFragmentFactory to use to create various fragments of this
        document.
        """
        assert fact is not None
        assert sources is not None
        assert not sources.isEmpty()
        assert renamingAliases is not None
        assert definedAliases is not None
        assert functions is not None
        assert scripts is not None
        assert scriptLinks is not None
        assert rep is not None
        super().__init__(sources, renamingAliases, definedAliases, functions,
                         scripts, scriptLinks, rep)
        self._factory = fact

    def writeDocument(self, w) -> None:
        #debug("---> OrgModeDocumentation.writeDocument(w) ...")
        assert w is not None
        self._writePrologue(w)
        self._writeIntroductionSection(w)
        self._writeSummariesSection(w)
        self._writeDescriptionsSection(w)
        self._writeIndexSection(w)
        self._writeEpilogue(w)

    def _writeIndentedParagraphs(self, w, indent: str,
                                 paras: List[Paragraph],
                                 d: Documentable) -> None:
        """
        Writes to 'w' the paragraphs in 'paras' in order so that every line
        is indented by preceding it with 'indent'.
        """
        assert w is not None
        assert indent is not None  # though it may be empty
        assert paras is not None
        assert d is not None
        p: Paragraph
        isFirst: bool = True
        for p in paras:
            if isFirst:
                isFirst = False
            else:
                self._writeLine(w)
            self._writeIndentedParagraph(w, indent, p, d)

    def _writeIndentedParagraph(self, w, indent: str, p: Paragraph,
                                d: Documentable) -> None:
        """
        Writes to 'w' the paragraph 'p' so that every line is indented by
        preceding it with 'indent', where 'p' is part of the documentation
        for 'd'.
        """
        #debug("---> OrgModeDocumentation._writeIndentedParagraph(w, {}, {}) ...", indent, p)
        assert w is not None
        assert indent is not None  # though it may be empty
        assert p is not None
        assert d is not None
        if BlockParser.isIndentedLine(p):
            self._writeVerbatimParagraph(w, indent, p)
        elif p.startswith(_usageParagraphStart):
            self._writeUsageParagraph(w, indent, p, d)
        elif p.startswith(_seeAlsoParagraphStart):
            self._writeSeeAlsoParagraph(w, indent, p, d)
        else:
            self._writeFlowedParagraph(w, indent, p)

    def _writeUsageParagraph(self, w, indent: str, p: Paragraph,
                             d: Documentable) -> None:
        """
        Writes to 'w' the paragraph 'p' so that every line is indented by
        preceding it with 'indent', where 'p' is assumed to specify a usage
        message for 'd'.

        FUTURE: handle usage messages with more than one line, one per
        different way of using it. (Right now we just assume there's only
        one.)
        """
        assert w is not None
        assert indent is not None  # though it may be empty
        assert p is not None
        assert p.startswith(_usageParagraphStart)
        assert d is not None
        # Output the 'usage:' prefix bolded and everything after it verbatim:
        # the part after it should more or less fit on a line, but even if it
        # doesn't we don't want to split it ourselves.
        fact: OrgModeFragmentFactory = self._factory
        prefix: str = _usageParagraphStart
        self._write(w, "{}{} ", indent, fact.makeBold(prefix))
        rest: str = p[len(prefix):].lstrip()
        if not rest:
            # There's nothing after 'usage:'.
            self._warnAt(d.firstLinePosition(), _missingUsageMessageFmt,
                         prefix, d.kindName(), d.formattedName())
        else:
            # The usage message doesn't start with the name of the
            # Documentable: either the name was omitted or it's incorrect.
            name: str = rest.split()[0]
                # the list isn't empty since 'rest' isn't
            if name != d.name():
                self._warnAt(d.firstLinePosition(),
                             _badUsageMessageProgramNameFmt, d.kindName(),
                             d.formattedName(), prefix, d.name())
        self._writeLine(w, fact.makeVerbatim(rest))

    def _writeSeeAlsoParagraph(self, w, indent: str, p: Paragraph,
                               d: Documentable) -> None:
        """
        Writes to 'w' the paragraph 'p' so that every line is indented by
        preceding it with 'indent', where 'p' is assumed to specify a list
        of aliases, functions, commands, etc. that are (more or less) related
        to 'd'.
        """
        assert w is not None
        assert indent is not None  # though it may be empty
        assert p is not None
        assert p.startswith(_seeAlsoParagraphStart)
        assert d is not None
        fact: OrgModeFragmentFactory = self._factory
        prefix: str = _seeAlsoParagraphStart
        rest: str = p[len(prefix):].lstrip()
        fullTxt: str = "{} ".format(fact.makeItalic(prefix))
        parts: List[str] = []
        if not rest:
            # There's nothing after 'See also:'.
            self._warnAt(d.firstLinePosition(), _missingSeeAlsoContentsFmt,
                         prefix, d.kindName(), d.formattedName())
        else:
            # Remove any period (.) at the end of the list.
            if rest.endswith("."):
                rest = rest[:-1]
            fullNames: List[str] = [x.strip() for x in rest.split(",")]
            funSuffix: str = _functionSpecifierSuffix
            name: str
            for name in fullNames:
                target: Optional[Documentable] = None
                linkTxt: str = name
                suffix: str = ""
                if name.endswith(funSuffix):
                    # We treat names ending in '()' specially by trying to
                    # match them to the name of a shell function first, and
                    # by not including the suffix in the link text if it
                    # turns out not to match a shell function.
                    name = name[:-len(funSuffix)]  # remove 'funSuffix'
                    target = self.findFunction(name)
                    if target is None:
                        self._noteAt(d.firstLinePosition(),
                                     _seeAlsoFunctionNotFunctionFmt,
                                     prefix, d.kindName(), d.formattedName(),
                                     linkTxt)
                        target = self.findDocumentable(name)
                        if target is not None:
                            linkTxt = name  # without the '()' suffix
                            suffix = funSuffix
                else:  # 'name' is just a plain name
                    target = self.findDocumentable(name)
                if target is None:  # there's nothing to link to
                    parts.append(fact.makeVerbatim(linkTxt))
                else:
                    target = target.findUltimateRenamed() or target
                        # since there's no Descriptions subsection for
                        # 'target' if it just renames something else
                    ref: str = self._documentableDescriptionReference(target)
                    link: str = fact.makeLink(ref, linkTxt)
                    parts.append("{}{}".format(link, suffix))
        # FUTURE: flow these into lines (which is complicated by the fact
        # that a link takes up less room than its actual text would suggest).
        self._write(w, indent)
        self._write(w, fullTxt)
        self._write(w, ", ".join(parts))
        self._writeLine(w, ".")

    def _writeVerbatimParagraph(self, w, indent: str, p: Paragraph) -> None:
        """
        Writes to 'w' the paragraph 'p' so that every line is indented by
        preceding it with 'indent' and lines are output unchanged/verbatim
        other than prepending the indentation 'indent'.

        See also: _writeFlowedParagraph().
        """
        assert w is not None
        assert indent is not None  # though it may be empty
        assert p is not None
        # We output indented paragraphs unchanged/verbatim (other than
        # prepending our extra indentation).
        #("convert-base" in p) and debug("==> writing [{}] verbatim", p)
        self._write(w, indent)
        self._writeLine(w, p)

    def _writeFlowedParagraph(self, w, indent: str, p: Paragraph) -> None:
        """
        Writes to 'w' the paragraph 'p' so that every line is indented by
        preceding it with 'indent' and lines are flowed together to make them
        all as close to being _lineWidth characters long as possible.

        See also: _writeVerbatimParagraph().
        """
        assert w is not None
        assert indent is not None  # though it may be empty
        assert p is not None
        assert not BlockParser.isIndentedLine(p)
            # since indented Paragraphs are output verbatim, not flowed (and
            # since we don't handle 'p' being indented)
        # FUTURE: break lines before we get to _lineWidth characters.
        #("convert-base" in p) and debug("==> writing [{}] flowed", p)
        width: int = _lineWidth - len(indent)
        rest: str = p
        while rest:
            line: str
            if len(rest) < width:
                line = rest
                rest = ""
            else:
                lastSpaceIndex: int = rest.rfind(" ", 0, width)
                if lastSpaceIndex < 0:
                    # There's no space in the first _lineWidth
                    # characters, so split on the next space.
                    lastSpaceIndex = rest.find(" ")
                if lastSpaceIndex < 0:
                    # There's no space to split on.
                    line = rest
                    rest = ""
                else:
                    # We omit the space we split on from both 'line' and
                    # 'rest': it's replaced by the newline after 'line'.
                    line = rest[:lastSpaceIndex]
                    rest = rest[lastSpaceIndex + 1:]
            if line:
                # The newline replaces the space that we split on.
                self._write(w, indent)
                self._writeLine(w, line)

    def _documentableDescriptionId(self, d: Documentable) -> str:
        """
        Returns the org mode CUSTOM_ID for the subsection of the
        'Descriptions' section of the document that we generate that
        describes the Documentable 'd'.
        """
        assert d is not None
        result: str = self._documentableDescriptionIdFmt.format(d.id())
        assert result
        return result

    def _documentableDescriptionReference(self, d: Documentable) -> str:
        """
        Returns the reference part of the org mode link to the subsection of
        the 'Descriptions' section of the document that we generate that
        describes the Documentable 'd'.
        """
        assert d is not None
        id: str = self._documentableDescriptionId(d)
        result: str = self._factory.makeIdReference(id)
        assert result
        return result

    def _pathnameLink(self, f: Pathname) -> str:
        """
        Returns the org mode document fragment representing a link to the
        absolute pathname 'f'.

        See also: LinePosition.displayablePathname(),
        _documentablePositionLink().
        """
        assert f is not None
        assert os.path.isabs(f)
        result: str = self._factory.makeDocumentableFileLink(f)
        assert result is not None
        return result

    def _documentablePositionLink(self, d: Documentable, txt: str) -> str:
        """
        Returns the org mode document fragment representing a link with the
        text 'txt' to the position of the start of the definition of 'd'.

        See also: _pathnameLink().
        """
        assert d is not None
        assert txt
        pos: LinePosition = d.firstLinePosition()
        f: Pathname = pos.pathname()
        assert os.path.isabs(f)
        result: str = self._localFileLink(f, txt, d.definitionStart())
        assert result is not None
        return result

    def _localFileLink(self, f: Pathname, linkText: str,
                       searchText: Optional[str] = None) -> str:
        """
        Returns an org mode link whose text displayed to the user is
        'linkText' and that links to the first(?) occurrence of 'searchText'
        in the local file with pathname 'f', to just to the start of that
        file if 'searchText' is empty or None.

        See also: _localFileReference().
        """
        assert f is not None
        assert os.path.isabs(f)
        assert linkText
        # 'searchText' can be None
        ref: str = self._localFileReference(f, searchText)
        result: str = self._factory.makeLink(ref, linkText)
        assert result
        return result

    def _localFileReference(self, f: Pathname,
                            searchText: Optional[str] = None) -> str:
        """
        Returns the reference part of an org mode link to the first(?)
        occurrence of 'searchText' in the local file with pathname 'f', or
        just to the start of that file if 'searchText' is empty or None.

        See also: _localFileLink().
        """
        assert f is not None
        assert os.path.isabs(f)
        # 'searchText' can be None
        fact: OrgModeFragmentFactory = self._factory
        result: str
        if searchText:
            result = fact.makeFileSearchReference(f, searchText)
        else:
            result = fact.makeFileReference(f)
        assert result
        return result

    def _descriptionLinkTarget(self, d: Documentable) -> Documentable:
        """
        Returns the Documentable whose 'Descriptions' section subsection is
        the one to link to for 'd'.
        """
        assert d is not None
        result: Optional[Documentable] = d.findUltimateRenamed()
        if (result is None) or d.hasDocumentation():
            # Use 'd' if it has documentation, or if it doesn't just rename
            # another Documentable.
            result = d
        assert result is not None
        return result


    def _writePrologue(self, w) -> None:
        """
        Writes to 'w' the prologue of the document that we generate.
        """
        assert w is not None
        self._write(w, _orgPrologueFmt, title = _title, author = _author)

    def _writeEpilogue(self, w) -> None:
        """
        Writes to 'w' the epilogue of the document that we generate.
        """
        assert w is not None
        now: datetime = datetime.datetime.now()
        #when: str = now.strftime("%H:%M.%S on %F")
        when: str = now.strftime("on %A %B %d, %Y at %H:%M.%S%P")
        w.write(_orgEpilogueFmt.format(when = when))

    def _writeIntroductionSection(self, w) -> None:
        """
        Writes to 'w' the introduction section of the document that we
        generate.
        """
        assert w is not None
        self._write(w, _orgIntroductionSectionStart)
        f: Pathname
        sources: DocumentablesSources = self.sources
        listItemFmt: str = "  - {}"
        isFirst: bool = True
        if sources.areFileSources():
            isFirst = False
            self._write(w, _orgFilesListStart)
            for f in sources.files():
                self._writeLine(w, listItemFmt,
                                LinePosition.displayablePathname(f))
        if sources.areDirectorySources():
            fmt: str = _orgDirectoriesListStart
            if isFirst:
                fmt = _orgDirectoriesListOnlyStart
            self._write(w, fmt)
            for f in sources.directories():
                self._writeLine(w, listItemFmt,
                                LinePosition.displayablePathname(f))

        ra: Dict[str, RenamingAlias] = self.renamingAliases
        da: Dict[str, DefinedAlias] = self.definedAliases
        self._writeLine(w, _orgIntroductionSectionEnd, len(ra) + len(da),
                        len(self.functions), len(self.scripts),
                        len(self.scriptLinks))

    def _writeSummariesSection(self, w) -> None:
        """
        Writes to 'w' the summaries section of the document that we
        generate.
        """
        assert w is not None
        self._writeLine(w, _orgSummariesSectionStart)
        d: Documentable
        for d in self.allDocumentables():
            self._writeOneSummary(w, d)

    def _writeOneSummary(self, w, d: Documentable) -> None:
        """
        Writes to 'w' the summary of 'd'.
        """
        assert w is not None
        assert d is not None
        fact: OrgModeFragmentFactory = self._factory
        target: Documentable = self._descriptionLinkTarget(d)
        #debug("===> d=[{}] :: target=[{}]", d, target)
        ref: str = self._documentableDescriptionReference(target)
        link: str = fact.makeLink(ref, d.formattedTypedName())
        self._writeLine(w, "  {} ::", link)
        indent: str = "    "
        if d.hasDocumentation():
            summary: List[Paragraph] = d.documentation().summary()
            if summary:
                self._writeIndentedParagraphs(w, indent, summary, d)
            else:
                self._write(w, indent)
                self._writeLine(w, _unsummarizedSummaryFmt, d.kindName())
        elif d.doesRename():
            self._write(w, indent)
            fmt: str
            if d != target:
                fmt = _defaultRenamesDocumentableSummaryFmt
                self._writeLine(w, fmt, d.renamerKindDescription(),
                                fact.makeLink(ref, target.name()))
            else:
                fmt = _defaultRenamesNondocumentableSummaryFmt
                self._writeLine(w, fmt, d.renamerKindDescription(),
                                fact.makeVerbatim(d.renamedName()))
        else:
            self._write(w, indent)
            self._writeLine(w, _undocumentedSummaryFmt, d.kindName())
        self._writeLine(w)

    def _writeDescriptionsSection(self, w) -> None:
        """
        Writes to 'w' the descriptions section of the document that we
        generate.
        """
        assert w is not None
        self._writeLine(w, _orgDescriptionsSectionStart)
        # We don't include subsections for undocumented Documentables that
        # just rename other Documentables since they'll be listed under one
        # of the ones they rename (and their summary and index links will
        # link to that Documentable's subsection instead).
        d: Documentable
        for d in self.allButUndocumentedRenamingDocumentables():
            self._writeOneDescription(w, d)

    def _writeOneDescription(self, w, d: Documentable) -> None:
        """
        Writes to 'w' the full description of 'd'.
        """
        assert w is not None
        assert d is not None
        fact: OrgModeFragmentFactory = self._factory
        self._writeLine(w, _orgDocumentableDescriptionStart,
                        d.formattedName(),
                        self._documentableDescriptionId(d))

        # Write out any and all other names that 'd' has.
        others: List[str] = d.otherNames()
        if others:
            self._writeLine(w, "Other names: {}.", ", ".join(others))
            self._writeLine(w)

        # Write out 'd''s full description if it has one, and a message
        # indicating it's undocumented otherwise.
        indent: str = ""  # no indentation
        didWrite: bool = False
        if d.hasDocumentation():
            desc: List[Paragraph] = d.documentation().fullDescription()
            if desc:
                self._writeIndentedParagraphs(w, indent, desc, d)
                didWrite = True
        elif d.doesRename():
            # If we get here then 'd' must rename a non-Documentable, since
            # if it renamed a Documentable it wouldn't have an entry in the
            # 'Descriptions' section: it would just be listed as another name
            # for the Documentable that it renames.
            fmt: str = _defaultRenamesNondocumentableSummaryFmt
            self._writeLine(w, fmt, d.renamerKindDescription(),
                            fact.makeVerbatim(d.renamedName()))
            didWrite = True

        if not didWrite:
            self._write(w, indent)
            self._writeLine(w, _undocumentedDescriptionFmt, d.kindName())

        pos: LinePosition = d.firstLinePosition()
        if d.isEntireFile():
            self._writeLine(w, _orgWholeFileDocumentableDescriptionEnd,
                            d.kindName(), self._pathnameLink(pos.pathname()))
        else:
            txt: str = "line {}".format(pos.lineNumber())
            self._writeLine(w, _orgDocumentableDescriptionEnd, d.kindName(),
                            self._documentablePositionLink(d, txt),
                            self._pathnameLink(pos.pathname()))

    def _writeIndexSection(self, w) -> None:
        """
        Writes to 'w' the index section of the document that we generate.
        """
        assert w is not None
        fact: OrgModeFragmentFactory = self._factory
        self._writeLine(w, _orgIndexSectionStart)
        sep: str = ","  # separates links in a group
        d: Documentable
        indent: str
        isFirst: bool = True
        prevInitial: str = ""
        usedWidth: int = 0
        for d in self.allDocumentables():
            name: str = d.name()
            initial: str = name[0].lower()  # caseless
            assert isFirst or prevInitial
            fname: str = d.formattedTypedName()
            if isFirst or (initial != prevInitial):
                if isFirst:
                    isFirst = False
                else:
                    # If we don't put a blank line between groups then the
                    # exported versions of the org mode document that we
                    # generate will run them all together into one paragraph.
                    assert prevInitial
                    self._writeLine(w)
                    self._writeLine(w)
                prefix: str = "{}: ".format(fact.makeBold(initial.upper()))
                sz: int = len(prefix)
                assert sz > 0
                indent = " " * sz  # same width as 'prefix'
                assert indent
                self._write(w, prefix)
                usedWidth = sz  # we've started a new line
            elif (usedWidth + len(fname) + len(sep)) >= _lineWidth:
                # There's not enough room on the current line to add
                # 'fname', so start a new (indented) line after putting
                # a separator at the end of the old line.
                assert indent  # should have been set in 'if' case above
                self._writeLine(w, sep)
                self._write(w, indent)
                usedWidth = len(indent)  # we've started a new line
            else:
                # Add the next link to the end of the current line (since
                # there's room for it).
                self._write(w, sep)
                self._write(w, " ")
                usedWidth += len(sep) + 1
            target: Documentable = self._descriptionLinkTarget(d)
            ref: str = self._documentableDescriptionReference(target)
            self._write(w, fact.makeLink(ref, fname))
            usedWidth += len(fname)
            prevInitial = initial
        self._writeLine(w)


class DocumentationBuilder(DocumentableHolder):
    """
    Builds Documentation instances.
    """
    def __init__(self, sources: DocumentablesSources, rep: Reporter) -> None:
        """
        Initializes us with the Reporter to use to report our progress in
        building our Documentation.
        """
        assert sources is not None
        assert not sources.isEmpty()
        assert rep is not None
        self._sources: DocumentablesSources = sources
        self._reporter: Reporter = rep
        self._renamingAliases: Dict[str, RenamingAlias] = {}
            # maps the names of renaming aliases to the aliases themselves
        self._definedAliases: Dict[str, DefinedAlias] = {}
            # maps the names of defined aliases to the aliases themselves
        self._functions: Dict[str, Function] = {}
            # maps the names of shell functions to the functions themselves
        self._scripts: Dict[str, Script] = {}
            # maps the (base)names of scripts to the scripts themselves
        self._scriptLinks: Dict[str, ScriptLink] = {}
            # maps the (base)names of links to scripts to the links
            # themselves

    def addRenamingAlias(self, d: RenamingAlias, rep: Reporter) -> bool:
        assert d is not None
        assert rep is not None
        result: bool = self._checkDocumentableName(d, rep)
        if result:
            name: str = d.name()
            existing: Optional[Alias] = self._findAliasNamed(name)
            if existing is not None:
                rep.warnAt(d.firstLinePosition(), _alreadyAliasFmt, name,
                           existing.firstLinePosition())
            else:
                # Aliases are allowed to hide/shadow all other types of
                # Documentables.
                self._reportAnyHiddenDocumentableNamed(name, d, rep)
                self._renamingAliases[name] = d
        return result

    def addDefinedAlias(self, d: DefinedAlias, rep: Reporter) -> bool:
        assert d is not None
        assert rep is not None
        result: bool = self._checkDocumentableName(d, rep)
        if result:
            name: str = d.name()
            existing: Optional[Alias] = self._findAliasNamed(name)
            if existing is not None:
                rep.warnAt(d.firstLinePosition(), _alreadyAliasFmt, name,
                           existing.firstLinePosition())
            else:
                # Aliases are allowed to hide/shadow all other types of
                # Documentables.
                self._reportAnyHiddenDocumentableNamed(name, d, rep)
                self._definedAliases[name] = d
        return result

    def addFunction(self, d: Function, rep: Reporter) -> bool:
        assert d is not None
        assert rep is not None
        result: bool = self._checkDocumentableName(d, rep)
        if result:
            name: str = d.name()
            existing: Optional[Documentable] = self._findAliasNamed(name)
            if existing is not None:
                # Aliases are allowed to hide/shadow functions, but we note
                # it in case we've done it inadvertently.
                rep.noteAt(d.firstLinePosition(), _alreadyAliasFmt, name,
                           existing.firstLinePosition())
            else:
                # We don't replace an existing shell function of the same
                # name.
                existing = self._findFunctionNamed(name)
                if existing is not None:
                    rep.warnAt(d.firstLinePosition(), _alreadyFunctionFmt,
                               name, existing.firstLinePosition())
                else:
                    # Shell functions are allowed to hide/shadow all other
                    # types of Documentables (except aliases).
                    self._reportAnyHiddenDocumentableNamed(name, d, rep)
                    self._functions[name] = d
        return result

    def addScript(self, d: Script, rep: Reporter) -> bool:
        #debug("---> DocumentationBuilder.addScript({}, rep) ...", d)
        assert d is not None
        assert rep is not None
        result: bool = self._checkDocumentableName(d, rep)
        if result:
            name: str = d.name()
            existing: Optional[Documentable] = \
                self._findAliasNamed(name) or self._findFunctionNamed(name)
            if existing is not None:
                # Aliases and shell functions are allowed to hide/shadow
                # scripts, but we note it in case we've done it
                # inadvertently.
                rep.noteAt(d.firstLinePosition(), _scriptHiddenFmt,
                           d.kindName(), name, existing.kindName(),
                           existing.firstLinePosition())
            else:
                # We don't replace an existing script or script link of the
                # same name.
                existing = self._findScriptNamed(name) or \
                    self._findScriptLinkNamed(name)
                if existing is not None:
                    rep.warnAt(d.firstLinePosition(), _alreadyScriptFmt,
                               name, existing.pathname())
                else:
                    # Scripts are allowed to hide/shadow all other types of
                    # Documentables (not that there are any right now).
                    self._reportAnyHiddenDocumentableNamed(name, d, rep)
                    self._scripts[name] = d
        return result

    def addScriptLink(self, d: ScriptLink, rep: Reporter) -> bool:
        #debug("---> DocumentationBuilder.addScriptLink({}, rep) ...", d)
        assert d is not None
        assert rep is not None
        result: bool = self._checkDocumentableName(d, rep)
        if result:
            name: str = d.name()
            existing: Optional[Documentable] = \
                self._findAliasNamed(name) or self._findFunctionNamed(name)
            if existing is not None:
                # Aliases and shell functions are allowed to hide/shadow
                # script links, but we note it in case we've done it
                # inadvertently.
                rep.noteAt(d.firstLinePosition(), _scriptHiddenFmt,
                           d.kindName(), name, existing.kindName(),
                           existing.firstLinePosition())
            else:
                # We don't replace an existing script or script link of the
                # same name.
                existing = self._findScriptNamed(name) or \
                    self._findScriptLinkNamed(name)
                if existing is not None:
                    rep.warnAt(d.firstLinePosition(), _alreadyScriptFmt,
                               name, existing.pathname())
                else:
                    # Script links are allowed to hide/shadow all other
                    # types of Documentables (not that there are any right
                    # now).
                    self._reportAnyHiddenDocumentableNamed(name, d, rep)
                    self._scriptLinks[name] = d
        return result

    def _reportAnyHiddenDocumentableNamed(self, name: str, d: Documentable,
                                          rep: Reporter) -> None:
        """
        If we already contain a Documentable named 'name' then we report that
        'd' hides/shadows it.
        """
        assert name is not None
        assert d is not None
        assert rep is not None
        existing: Optional[Documentable] = self._findDocumentableNamed(name)
        if existing is not None:
            rep.noteAt(d.firstLinePosition(), _hidesDocumentableFmt,
                       existing.kindName(), name,
                       existing.firstLinePosition())


    def buildOrg(self, fact: OrgModeFragmentFactory) -> \
                                            Optional[OrgModeDocumentation]:
        """
        Builds and returns the Documentation in org mode format using 'fact',
        or returns None if one or more errors (and not just warnings or
        notes) were reported in the process.
        """
        assert fact is not None
        self._processAllSources()
        result: Optional[OrgModeDocumentation] = None
        if self._reporter.errorCount() == 0:
            self._buildAllRenamingChains()
            result = OrgModeDocumentation(fact, self._sources,
                                          self._renamingAliases,
                                          self._definedAliases,
                                          self._functions, self._scripts,
                                          self._scriptLinks, self._reporter)
            assert result is not None
        # 'result' can be None
        return result

    def _processAllSources(self) -> None:
        """
        Processes all of sources of Documentables specified by our
        DocumentablesSources.
        """
        f: Pathname
        sources: DocumentablesSources = self._sources
        rep: Reporter = self._reporter

        # Process all of the sources that are directories.
        for f in sources.directories():
            if not os.path.exists(f):
                rep.warn(_noSuchDirectoryFmt, f)
            else:
                self._processDirectory(os.path.abspath(f))

        # Process all of the sources that are regular files.
        for f in sources.files():
            if not os.path.exists(f):
                rep.warn(_noSuchFileFmt, f)
            else:
                self._processFile(os.path.abspath(f))

    def _processDirectory(self, d: Pathname) -> None:
        """
        Causes us to process the directory with pathname 'd' (usually by
        processing what's in and - possibly - under it), where 'd' is assumed
        to be one of the sources in our DocumentablesSources.
        """
        #debug("---> DocumentationBuilder._processDirectory({}) ...", d)
        assert d is not None
        sources: DocumentablesSources = self._sources
        assert sources.hasDirectory(d)
        f: Pathname
        for f in sources.directoryContents(d):
            f = os.path.join(d, f)
            if os.path.islink(f):
                self._processPossibleScriptLink(f)
            else:
                assert os.path.isfile(f)
                    # guaranteed by sources.directoryContents()
                self._processPossibleScript(f)

    def _processPossibleScriptLink(self, f: Pathname) -> None:
        """
        Causes us to process the regular file with pathname 'f' as a possible
        symlink to a script.
        """
        #debug("---> DocumentationBuilder._processPossibleScriptLink({}) ...", f)
        assert f is not None
        assert os.path.islink(f)
        with open(f) as r:
            line: Optional[str] = self._tryToReadFirstLineOfFile(r)
            if line and line.startswith(_scriptStart):
                # We assume 'f' is symlink to a script.
                self.addScriptLink(ScriptLink(f), self._reporter)

    def _processPossibleScript(self, f: Pathname) -> None:
        """
        Causes us to process the regular file with pathname 'f' as a possible
        script.
        """
        #debug("---> DocumentationBuilder._processPossibleScript({}) ...", f)
        assert f is not None
        assert os.path.isfile(f)
        with open(f) as r:
            rep: Reporter = self._reporter
            line: Optional[str] = self._tryToReadFirstLineOfFile(r)
            if line and line.startswith(_scriptStart):
                # We assume 'f' is a script. Discard its first line ...
                #debug("    discarding the first line of the script '{}'", f)
                line = r.readline()
                pos: LinePosition = LinePosition(f, 2)
                if re.match(_emacsLineRegex, line) is not None:
                    # ... and discard the second line as well.
                    #debug("    discarding the second line of '{}' as well", f)
                    line = r.readline()
                    pos.incrementLineNumber()
                if BlockParser.isCommentLine(line):
                    #debug("    next line of script is a comment line ...")
                    b: CommentBlock = \
                        self._parseScriptCommentBlock(line, pos, r, rep)
                    #debug("    parsed it into a CommentBlock at {}", pos)
                    excludes: List[str] = _excludeFromScriptDocsRegexes
                    doc: ItemDocumentation = \
                        ItemDocumentation.parseComments(b, rep, excludes)
                    #debug("    then converted that into an ItemDocumentation")
                    self.addScript(Script(f, doc), rep)
                else:
                    rep.warnAt(pos, _undocumentedScriptFmt)
            else:
                pos: LinePosition = LinePosition(f, 1)
                rep.informAt(pos, _ignoringNonscriptFmt, _scriptStart)

    def _tryToReadFirstLineOfFile(self, r) -> Optional[str]:
        """
        Reads and returns the first line of the file that the readable
        stream 'r' is open on - including the terminating newline - or
        returns None if that line can't be read (e.g. because it isn't
        open on a text file).
        """
        assert r is not None
        result: Optional[str]
        try:
            result = r.readline()
        except UnicodeDecodeError:
            # This can often happen if we're reading a binary file, though
            # it may not in some cases.
            result = None
        # 'result' can be None
        return result

    def _parseScriptCommentBlock(self, line: str, pos: LinePosition, r,
                                 rep: Reporter) -> CommentBlock:
        """
        Returns the CommentBlock resulting from parsing the comment line
        'line' at position 'pos' in a script and any and all subsequent
        comment lines in the script, which can be read from 'r'. Any and all
        problems and issues are reported using 'rep'.

        Note: we may read from 'r' (and discard) the line after the script's
        top comment.
        """
        assert line is not None
        assert BlockParser.isCommentLine(line)
        assert pos is not None
        assert r is not None
        assert rep is not None
        result: CommentBlock = CommentBlock(line, pos)
        indentSz: int = result.indentSize()
        if indentSz > 0:
            rep.noteAt(pos, _scriptCommentIndentedFmt)
        while True:
            nextLine: str = readNextLineFrom(r, pos)
            if (nextLine is None) or not BlockParser.isCommentLine(nextLine):
                break  # while
            if result.lineIndentSize(nextLine, pos) != indentSz:
                rep.noteAt(pos, _differentScriptCommentLineIndentFmt)
            result.addLine(nextLine, pos)
        assert result is not None
        return result

    def _processFile(self, f: Pathname) -> None:
        """
        Causes us to process the file with pathname 'f' of (possibly among
        other things) bash alias and shell function definitions to include
        them in the Documentation we're building, where 'd' is assumed to be
        one of the sources in our DocumentablesSources.

        We assume that the file with pathname 'f' exists and is a regular
        file.
        """
        #debug("---> DocumentationBuilder._processFile({}) ...", f)
        assert f is not None
        assert self._sources.hasFile(f)  # *not* a precondition
        rep: Reporter = self._reporter
        with open(f) as r:
            blocks: List[Block] = []
            parser: BlockParser = BlockParser(r, f, rep)
            b: Optional[Block]
            while True:
                b = parser.parseNextBlock()
                if b is None:
                    # There are no more Blocks in 'f'.
                    break  # while
                blocks.append(b)
                if len(blocks) >= 2:
                    self._convertFirstBlocksToDocumentables(blocks)
            if blocks:
                assert len(blocks) == 1
                blocks[0].convertLastToDocumentables(self, rep)

    def _convertFirstBlocksToDocumentables(self,
                                           blocks: List[Block]) -> None:
        """
        Converts the first Blocks in 'blocks' into zero or more
        Documentables and adds them to us. Any and all converted Blocks are
        removed from 'blocks'.
        """
        assert blocks is not None
        assert len(blocks) >= 2
        numUsed: int = blocks[1].convertToDocumentables(blocks[0], self,
                                                        self._reporter)
        if numUsed > 0:
            # Remove from 'blocks' any and all Blocks that were converted
            # into Documentables and added to us.
            del blocks[:numUsed]

    def _buildAllRenamingChains(self) -> None:
        """
        Builds the renaming chains for all of our Documentables that rename
        another one of our Documentables.

        See also: _buildAllAliasRenamingChains(),
        _buildAllScriptLinkRenamingChains().
        """
        #debug("--> _buildAllRenamingChains() ...")
        self._buildAllScriptLinkRenamingChains()
        self._buildAllAliasRenamingChains()

    def _buildAllScriptLinkRenamingChains(self) -> None:
        """
        Builds the renaming chains for all of our ScriptLinks.

        See also: ScriptLink.setLinkedScript().
        """
        #debug("---> _buildAllScriptLinkRenamingChains() ...")
        k: str
        v: ScriptLink
        for (k, v) in self._scriptLinks.items():
            renamedName: str = v.renamedName()
            assert renamedName
            s: Optional[Script] = self._findScriptNamed(renamedName)
            if s is not None:
                if v.maybeSetLinkedScript(s):
                    s.addOtherName(k)

    def _buildAllAliasRenamingChains(self) -> None:
        """
        Builds the renaming chains for all of our RenamingAliases.

        See: RenamingAlias.addToRenamingChain().
        """
        #debug("--> _buildAllAliasRenamingChains() ...")
        rep: Reporter = self._reporter
        k: str
        v: RenamingAlias
        for (k, v) in self._renamingAliases.items():
            #debug("    processing renaming alias '{}' ...", k)
            renamedName: str = v.renamedName()
            assert renamedName
            #debug("      - renames the name '{}'", renamedName)

            # All of the Documentables in the chain except possibly the last
            # are RenamingAliases (since they're the only ones that can
            # rename a Documentable).
            while True:
                ra: Optional[RenamingAlias] = \
                    self._renamingAliases.get(renamedName)
                if ra is None:
                    break  # while
                if v.addRenamingToRenamingChain(ra, rep):
                    renamedName = ra.renamedName()
                    ra.addOtherName(k)
                else:
                    break  # while

            # The last Documentable in the chain may have been a
            # RenamingAlias, but it could also be something else.
            d: Optional[Documentable] = \
                self._findDocumentableNamed(renamedName)
            if d is not None:
                if v.addNonrenamingToRenamingChain(d, rep):
                    d.addOtherName(k)

    def _findAliasNamed(self, name: str) -> Optional[Alias]:
        """
        Returns the alias named 'name' that we hold, or returns None if an
        alias of that name hasn't been added to us yet.

        See also: _findDocumentableNamed().
        """
        assert name is not None
        result: Optional[Alias] = self._renamingAliases.get(name)
        if result is None:
            result = self._definedAliases.get(name)
        # 'result' can be None
        return result

    def _findFunctionNamed(self, name: str) -> Optional[Function]:
        """
        Returns the shell function named 'name' that we hold, or returns None
        if a function of that name hasn't been added to us yet.
        """
        assert name is not None
        result: Optional[Function] = self._functions.get(name)
        # 'result' can be None
        return result

    def _findScriptNamed(self, name: str) -> Optional[Script]:
        """
        Returns the script named 'name' that we hold, or returns None if a
        script of that name hasn't been added to us yet.
        """
        assert name is not None
        result: Optional[Script] = self._scripts.get(name)
        # 'result' can be None
        return result

    def _findScriptLinkNamed(self, name: str) -> Optional[ScriptLink]:
        """
        Returns the script link named 'name' that we hold, or returns None if
        a script link of that name hasn't been added to us yet.
        """
        assert name is not None
        result: Optional[ScriptLink] = self._scriptLinks.get(name)
        # 'result' can be None
        return result

    def _findDocumentableNamed(self, name: str) -> Optional[Documentable]:
        """
        Returns the Documentable named 'name' that we hold, or returns None
        of a Documentable with that name hasn't been added to us yet.
        """
        assert name is not None
        result: Optional[Documentable] = self._findAliasNamed(name) or \
            self._findFunctionNamed(name) or self._findScriptNamed(name) or \
            self._findScriptLinkNamed(name)
        # 'result' can be None
        return result

    def _checkDocumentableName(self, d: Documentable, rep: Reporter) -> bool:
        """
        Checks that the name of 'd' is that of one we're willing to document,
        and reports a warning and returns False if it isn't.
        """
        assert d is not None
        assert rep is not None
        result: bool = True
        name: str = d.name()
        if name.startswith(_shellVariableStart):
            # We don't document things whose names look like they evaluate
            # to a shell variable's value (e.g. '$s') since that's almost
            # certainly not their real name.
            #
            # Note that we currently have no good way to document such
            # aliases, functions, etc. since we have no good way to determine
            # their actual names.
            result = False
            rep.warnAt(d.firstLinePosition(), _shellVariableAsNameFmt,
                       d.kindName(), name, _shellVariableStart)
        return result


##
## Main program.
##

def main():
    """
    Performs the actions indicated by the command line arguments when this
    file is executed directly, returning the exit code that we're to exit
    with: 0 on success, > 0 on failure.
    """
    result: int = 0
    rfact: ReporterFactory = ReporterFactory()
    srep: SelectiveReporter = rfact.makeSelective(rfact.makeStderr())
    srep.setReportNoteOrWorse()  # the default
    doLinkIntoScriptsOrgFiles: bool = False
    isDone: bool = False
    try:
        opts, args = getopt.getopt(sys.argv[1:], "hqPsv")
        for opt, val in opts:
            if opt == "-h":
                usage(w = sys.stdout)
                isDone = True
            elif opt == "-q":  # quiet
                srep.setReportWarningOrWorse()
            elif opt == "-s":  # silent
                srep.setReportNothing()
            elif opt == "-v":  # verbose
                srep.setReportInfoOrWorse()
            elif opt == "-P":
                # Include links into scripts.org files wherever possible in
                # the document that we generate.
                doLinkIntoScriptsOrgFiles = True
            else:
                usage(msg = "unhandled option: '{}'".format(opt))
                isDone = True
    except getopt.error as ex:
        usage("Invalid option '{}': {}".format(ex.opt, ex.msg))
        result = 1

    if not isDone and (result == 0):
        if not args:
            usage("No files were specified.")
            result = 1
        else:
            rep: CountingReporter = rfact.makeCounting(srep)
            sources: DocumentablesSources = DocumentablesSources(args, rep)
            b: DocumentationBuilder = DocumentationBuilder(sources, rep)
            fact: OrgModeFragmentFactory
            if doLinkIntoScriptsOrgFiles:
                fact = PersonalOrgModeFragmentFactory()
            else:
                fact = OrgModeFragmentFactory()
            doc: Optional[Documentation] = b.buildOrg(fact)
            if doc is not None:
                # No errors occurred in building the documentation (though
                # there may have been warnings or notes).
                doc.writeDocument(sys.stdout)
    assert result >= 0
    return result


if __name__ == '__main__':
    rc: int = main()
    sys.exit(rc)
